{"version":3,"file":"stimulus.min.js","sources":["../src/core/event_listener.ts","../src/core/dispatcher.ts","../src/core/action_descriptor.ts","../src/core/string_helpers.ts","../src/core/action.ts","../src/core/binding.ts","../src/mutation-observers/element_observer.ts","../src/mutation-observers/attribute_observer.ts","../src/mutation-observers/string_map_observer.ts","../src/multimap/set_operations.ts","../src/multimap/multimap.ts","../src/multimap/indexed_multimap.ts","../src/mutation-observers/token_list_observer.ts","../src/mutation-observers/value_list_observer.ts","../src/core/binding_observer.ts","../src/core/value_observer.ts","../src/core/target_observer.ts","../src/core/context.ts","../src/core/inheritable_statics.ts","../src/core/blessing.ts","../src/core/module.ts","../src/core/definition.ts","../src/core/class_map.ts","../src/core/data_map.ts","../src/core/guide.ts","../src/core/selectors.ts","../src/core/target_set.ts","../src/core/scope.ts","../src/core/scope_observer.ts","../src/core/router.ts","../src/core/schema.ts","../src/core/application.ts","../src/core/value_properties.ts","../src/core/controller.ts","../src/core/class_properties.ts","../src/core/target_properties.ts"],"sourcesContent":["import { Binding } from \"./binding\"\n\nexport class EventListener implements EventListenerObject {\n  readonly eventTarget: EventTarget\n  readonly eventName: string\n  readonly eventOptions: AddEventListenerOptions\n  private unorderedBindings: Set<Binding>\n\n  constructor(eventTarget: EventTarget, eventName: string, eventOptions: AddEventListenerOptions) {\n    this.eventTarget = eventTarget\n    this.eventName = eventName\n    this.eventOptions = eventOptions\n    this.unorderedBindings = new Set()\n  }\n\n  connect() {\n    this.eventTarget.addEventListener(this.eventName, this, this.eventOptions)\n  }\n\n  disconnect() {\n    this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions)\n  }\n\n  // Binding observer delegate\n\n  bindingConnected(binding: Binding) {\n    this.unorderedBindings.add(binding)\n  }\n\n  bindingDisconnected(binding: Binding) {\n    this.unorderedBindings.delete(binding)\n  }\n\n  handleEvent(event: Event) {\n    // FIXME: Determine why TS won't recognize that the extended event has immediatePropagationStopped\n    const extendedEvent = extendEvent(event) as any\n    for (const binding of this.bindings) {\n      if (extendedEvent.immediatePropagationStopped) {\n        break\n      } else {\n        binding.handleEvent(extendedEvent)\n      }\n    }\n  }\n\n  get bindings(): Binding[] {\n    return Array.from(this.unorderedBindings).sort((left, right) => {\n      const leftIndex = left.index, rightIndex = right.index\n      return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0\n    })\n  }\n\n}\n\nfunction extendEvent(event: Event) {\n  if (\"immediatePropagationStopped\" in event) {\n    return event\n  } else {\n    const { stopImmediatePropagation } = event\n    return Object.assign(event, {\n      immediatePropagationStopped: false,\n      stopImmediatePropagation() {\n        this.immediatePropagationStopped = true\n        stopImmediatePropagation.call(this)\n      }\n    })\n  }\n}\n","import { Application } from \"./application\"\nimport { Binding } from \"./binding\"\nimport { BindingObserverDelegate } from \"./binding_observer\"\nimport { EventListener } from \"./event_listener\"\n\nexport class Dispatcher implements BindingObserverDelegate {\n  readonly application: Application\n  private eventListenerMaps: Map<EventTarget, Map<string, EventListener>>\n  private started: boolean\n\n  constructor(application: Application) {\n    this.application = application\n    this.eventListenerMaps = new Map\n    this.started = false\n  }\n\n  start() {\n    if (!this.started) {\n      this.started = true\n      this.eventListeners.forEach(eventListener => eventListener.connect())\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.started = false\n      this.eventListeners.forEach(eventListener => eventListener.disconnect())\n    }\n  }\n\n  get eventListeners(): EventListener[] {\n    return Array.from(this.eventListenerMaps.values())\n      .reduce((listeners, map) => listeners.concat(Array.from(map.values())), [] as EventListener[])\n  }\n\n  // Binding observer delegate\n\n  bindingConnected(binding: Binding) {\n    this.fetchEventListenerForBinding(binding).bindingConnected(binding)\n  }\n\n  bindingDisconnected(binding: Binding) {\n    this.fetchEventListenerForBinding(binding).bindingDisconnected(binding)\n  }\n\n  // Error handling\n\n  handleError(error: Error, message: string, detail: object = {}) {\n    this.application.handleError(error, `Error ${message}`, detail)\n  }\n\n  private fetchEventListenerForBinding(binding: Binding): EventListener {\n    const { eventTarget, eventName, eventOptions } = binding\n    return this.fetchEventListener(eventTarget, eventName, eventOptions)\n  }\n\n  private fetchEventListener(eventTarget: EventTarget, eventName: string, eventOptions: AddEventListenerOptions): EventListener {\n    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget)\n    const cacheKey = this.cacheKey(eventName, eventOptions)\n    let eventListener = eventListenerMap.get(cacheKey)\n    if (!eventListener) {\n      eventListener = this.createEventListener(eventTarget, eventName, eventOptions)\n      eventListenerMap.set(cacheKey, eventListener)\n    }\n    return eventListener\n  }\n\n  private createEventListener(eventTarget: EventTarget, eventName: string, eventOptions: AddEventListenerOptions): EventListener {\n    const eventListener = new EventListener(eventTarget, eventName, eventOptions)\n    if (this.started) {\n      eventListener.connect()\n    }\n    return eventListener\n  }\n\n  private fetchEventListenerMapForEventTarget(eventTarget: EventTarget): Map<string, EventListener> {\n    let eventListenerMap = this.eventListenerMaps.get(eventTarget)\n    if (!eventListenerMap) {\n      eventListenerMap = new Map\n      this.eventListenerMaps.set(eventTarget, eventListenerMap)\n    }\n    return eventListenerMap\n  }\n\n  private cacheKey(eventName: string, eventOptions: any): string {\n    const parts = [ eventName ]\n    Object.keys(eventOptions).sort().forEach(key => {\n      parts.push(`${eventOptions[key] ? \"\" : \"!\"}${key}`)\n    })\n    return parts.join(\":\")\n  }\n}\n","import { EventModifiers } from \"./event_modifiers\"\n\nexport interface ActionDescriptor {\n  eventTarget: EventTarget\n  eventOptions: EventModifiers\n  eventName: string\n  identifier: string\n  methodName: string\n}\n\n// capture nos.:            12   23 4               43   1 5   56 7      768 9  98\nconst descriptorPattern = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/\n\nexport function parseActionDescriptorString(descriptorString: string): Partial<ActionDescriptor> {\n  const source = descriptorString.trim()\n  const matches = source.match(descriptorPattern) || []\n  return {\n    eventTarget:  parseEventTarget(matches[4]),\n    eventName:    matches[2],\n    eventOptions: matches[9] ? parseEventOptions(matches[9]) : {},\n    identifier:   matches[5],\n    methodName:   matches[7]\n  }\n}\n\nfunction parseEventTarget(eventTargetName: string): EventTarget | undefined {\n  if (eventTargetName == \"window\") {\n    return window\n  } else if (eventTargetName == \"document\") {\n    return document\n  }\n}\n\nfunction parseEventOptions(eventOptions: string): EventModifiers {\n  return eventOptions.split(\":\").reduce((options, token) =>\n    Object.assign(options, { [token.replace(/^!/, \"\")]: !/^!/.test(token) })\n  , {})\n}\n\nexport function stringifyEventTarget(eventTarget: EventTarget) {\n  if (eventTarget == window) {\n    return \"window\"\n  } else if (eventTarget == document) {\n    return \"document\"\n  }\n}\n","export function camelize(value: string) {\n  return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase())\n}\n\nexport function capitalize(value: string) {\n  return value.charAt(0).toUpperCase() + value.slice(1)\n}\n\nexport function dasherize(value: string) {\n  return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`)\n}\n\nexport function tokenize(value: string) {\n  return value.match(/[^\\s]+/g) || []\n}\n","import { ActionDescriptor, parseActionDescriptorString, stringifyEventTarget } from \"./action_descriptor\"\nimport { Token } from \"../mutation-observers\"\nimport { camelize } from \"./string_helpers\"\nimport { EventModifiers } from \"./event_modifiers\"\n\nexport class Action {\n  readonly element: Element\n  readonly index: number\n  readonly eventTarget: EventTarget\n  readonly eventName: string\n  readonly eventOptions: EventModifiers\n  readonly identifier: string\n  readonly methodName: string\n\n  static forToken(token: Token) {\n    return new this(token.element, token.index, parseActionDescriptorString(token.content))\n  }\n\n  constructor(element: Element, index: number, descriptor: Partial<ActionDescriptor>) {\n    this.element      = element\n    this.index        = index\n    this.eventTarget  = descriptor.eventTarget || element\n    this.eventName    = descriptor.eventName || getDefaultEventNameForElement(element) || error(\"missing event name\")\n    this.eventOptions = descriptor.eventOptions || {}\n    this.identifier   = descriptor.identifier || error(\"missing identifier\")\n    this.methodName   = descriptor.methodName || error(\"missing method name\")\n  }\n\n  toString() {\n    const eventNameSuffix = this.eventTargetName ? `@${this.eventTargetName}` : \"\"\n    return `${this.eventName}${eventNameSuffix}->${this.identifier}#${this.methodName}`\n  }\n\n  get params() {\n    const params:{ [key: string]: any } = {}\n    const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`)\n\n    for (const { name, value } of Array.from(this.element.attributes)) {\n      const match = name.match(pattern)\n      const key = match && match[1]\n      if (key) {\n        params[camelize(key)]= typecast(value)\n      }\n    }\n    return params\n  }\n\n  private get eventTargetName() {\n    return stringifyEventTarget(this.eventTarget)\n  }\n}\n\nconst defaultEventNames: { [tagName: string]: (element: Element) => string } = {\n  \"a\":        e => \"click\",\n  \"button\":   e => \"click\",\n  \"form\":     e => \"submit\",\n  \"details\":  e => \"toggle\",\n  \"input\":    e => e.getAttribute(\"type\") == \"submit\" ? \"click\" : \"input\",\n  \"select\":   e => \"change\",\n  \"textarea\": e => \"input\"\n}\n\nexport function getDefaultEventNameForElement(element: Element): string | undefined {\n  const tagName = element.tagName.toLowerCase()\n  if (tagName in defaultEventNames) {\n    return defaultEventNames[tagName](element)\n  }\n}\n\nfunction error(message: string): never {\n  throw new Error(message)\n}\n\nfunction typecast(value: any): any {\n  try {\n    return JSON.parse(value)\n  } catch (o_O) {\n    return value\n  }\n}\n\n","import { Action } from \"./action\"\nimport { ActionEvent } from \"./action_event\"\nimport { Context } from \"./context\"\nimport { Controller } from \"./controller\"\nimport { Scope } from \"./scope\"\nimport { EventModifiers } from \"./event_modifiers\"\n\nexport class Binding {\n  readonly context: Context\n  readonly action: Action\n\n  constructor(context: Context, action: Action) {\n    this.context = context\n    this.action = action\n  }\n\n  get index(): number {\n    return this.action.index\n  }\n\n  get eventTarget(): EventTarget {\n    return this.action.eventTarget\n  }\n\n  get eventOptions(): EventModifiers {\n    return this.action.eventOptions\n  }\n\n  get identifier(): string {\n    return this.context.identifier\n  }\n\n  handleEvent(event: Event) {\n    if (this.willBeInvokedByEvent(event) && this.shouldBeInvokedPerSelf(event)) {\n      this.processStopPropagation(event);\n      this.processPreventDefault(event);\n\n      this.invokeWithEvent(event)\n    }\n  }\n\n  get eventName(): string {\n    return this.action.eventName\n  }\n\n  get method(): Function {\n    const method = (this.controller as any)[this.methodName]\n    if (typeof method == \"function\") {\n      return method\n    }\n    throw new Error(`Action \"${this.action}\" references undefined method \"${this.methodName}\"`)\n  }\n\n  private processStopPropagation(event: Event) {\n    if (this.eventOptions.stop) {\n      event.stopPropagation();\n    }\n  }\n\n  private processPreventDefault(event: Event) {\n    if (this.eventOptions.prevent) {\n      event.preventDefault();\n    }\n  }\n\n  private invokeWithEvent(event: Event) {\n    const { target, currentTarget } = event\n    try {\n      const { params } = this.action\n      const actionEvent: ActionEvent = Object.assign(event, { params })\n      this.method.call(this.controller, actionEvent)\n      this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName })\n    } catch (error) {\n      const { identifier, controller, element, index } = this\n      const detail = { identifier, controller, element, index, event }\n      this.context.handleError(error, `invoking action \"${this.action}\"`, detail)\n    }\n  }\n\n  private shouldBeInvokedPerSelf(event: Event): boolean {\n    if (this.action.eventOptions.self === true) {\n      return this.action.element === event.target\n    } else {\n      return true\n    }\n  }\n\n  private willBeInvokedByEvent(event: Event): boolean {\n    const eventTarget = event.target\n    if (this.element === eventTarget) {\n      return true\n    } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {\n      return this.scope.containsElement(eventTarget)\n    } else {\n      return this.scope.containsElement(this.action.element)\n    }\n  }\n\n  private get controller(): Controller {\n    return this.context.controller\n  }\n\n  private get methodName(): string {\n    return this.action.methodName\n  }\n\n  private get element(): Element {\n    return this.scope.element\n  }\n\n  private get scope(): Scope {\n    return this.context.scope\n  }\n}\n","export interface ElementObserverDelegate {\n  matchElement(element: Element): boolean\n  matchElementsInTree(tree: Element): Element[]\n\n  elementMatched?(element: Element): void\n  elementUnmatched?(element: Element): void\n  elementAttributeChanged?(element: Element, attributeName: string): void\n}\n\nexport class ElementObserver {\n  element: Element\n  started: boolean\n  private delegate: ElementObserverDelegate\n\n  private elements: Set<Element>\n  private mutationObserver: MutationObserver\n  private mutationObserverInit = { attributes: true, childList: true, subtree: true }\n\n  constructor(element: Element, delegate: ElementObserverDelegate) {\n    this.element = element\n    this.started = false\n    this.delegate = delegate\n\n    this.elements = new Set\n    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations))\n  }\n\n  start() {\n    if (!this.started) {\n      this.started = true\n      this.mutationObserver.observe(this.element, this.mutationObserverInit)\n      this.refresh()\n    }\n  }\n\n  pause(callback: () => void) {\n    if (this.started) {\n      this.mutationObserver.disconnect()\n      this.started = false\n    }\n\n    callback()\n\n    if (!this.started) {\n      this.mutationObserver.observe(this.element, this.mutationObserverInit)\n      this.started = true\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.mutationObserver.takeRecords()\n      this.mutationObserver.disconnect()\n      this.started = false\n    }\n  }\n\n  refresh() {\n    if (this.started) {\n      const matches = new Set(this.matchElementsInTree())\n\n      for (const element of Array.from(this.elements)) {\n        if (!matches.has(element)) {\n          this.removeElement(element)\n        }\n      }\n\n      for (const element of Array.from(matches)) {\n        this.addElement(element)\n      }\n    }\n  }\n\n  // Mutation record processing\n\n  private processMutations(mutations: MutationRecord[]) {\n    if (this.started) {\n      for (const mutation of mutations) {\n        this.processMutation(mutation)\n      }\n    }\n  }\n\n  private processMutation(mutation: MutationRecord) {\n    if (mutation.type == \"attributes\") {\n      this.processAttributeChange(mutation.target, mutation.attributeName!)\n    } else if (mutation.type == \"childList\") {\n      this.processRemovedNodes(mutation.removedNodes)\n      this.processAddedNodes(mutation.addedNodes)\n    }\n  }\n\n  private processAttributeChange(node: Node, attributeName: string) {\n    const element = node as Element\n    if (this.elements.has(element)) {\n      if (this.delegate.elementAttributeChanged && this.matchElement(element)) {\n        this.delegate.elementAttributeChanged(element, attributeName)\n      } else {\n        this.removeElement(element)\n      }\n    } else if (this.matchElement(element)) {\n      this.addElement(element)\n    }\n  }\n\n  private processRemovedNodes(nodes: NodeList) {\n    for (const node of Array.from(nodes)) {\n      const element = this.elementFromNode(node)\n      if (element) {\n        this.processTree(element, this.removeElement)\n      }\n    }\n  }\n\n  private processAddedNodes(nodes: NodeList) {\n    for (const node of Array.from(nodes)) {\n      const element = this.elementFromNode(node)\n      if (element && this.elementIsActive(element)) {\n        this.processTree(element, this.addElement)\n      }\n    }\n  }\n\n  // Element matching\n\n  private matchElement(element: Element): boolean {\n    return this.delegate.matchElement(element)\n  }\n\n  private matchElementsInTree(tree: Element = this.element): Element[] {\n    return this.delegate.matchElementsInTree(tree)\n  }\n\n  private processTree(tree: Element, processor: (element: Element) => void) {\n    for (const element of this.matchElementsInTree(tree)) {\n      processor.call(this, element)\n    }\n  }\n\n  private elementFromNode(node: Node): Element | undefined {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      return node as Element\n    }\n  }\n\n  private elementIsActive(element: Element): boolean {\n    if (element.isConnected != this.element.isConnected) {\n      return false\n    } else {\n      return this.element.contains(element)\n    }\n  }\n\n  // Element tracking\n\n  private addElement(element: Element) {\n    if (!this.elements.has(element)) {\n      if (this.elementIsActive(element)) {\n        this.elements.add(element)\n        if (this.delegate.elementMatched) {\n          this.delegate.elementMatched(element)\n        }\n      }\n    }\n  }\n\n  private removeElement(element: Element) {\n    if (this.elements.has(element)) {\n      this.elements.delete(element)\n      if (this.delegate.elementUnmatched) {\n        this.delegate.elementUnmatched(element)\n      }\n    }\n  }\n}\n","import { ElementObserver, ElementObserverDelegate } from \"./element_observer\"\n\nexport interface AttributeObserverDelegate {\n  elementMatchedAttribute?(element: Element, attributeName: string): void\n  elementAttributeValueChanged?(element: Element, attributeName: string): void\n  elementUnmatchedAttribute?(element: Element, attributeName: string): void\n}\n\nexport class AttributeObserver implements ElementObserverDelegate {\n  attributeName: string\n  private delegate: AttributeObserverDelegate\n\n  private elementObserver: ElementObserver\n\n  constructor(element: Element, attributeName: string, delegate: AttributeObserverDelegate) {\n    this.attributeName = attributeName\n    this.delegate = delegate\n\n    this.elementObserver = new ElementObserver(element, this)\n  }\n\n  get element(): Element {\n    return this.elementObserver.element\n  }\n\n  get selector(): string {\n    return `[${this.attributeName}]`\n  }\n\n  start() {\n    this.elementObserver.start()\n  }\n\n  pause(callback: () => void) {\n    this.elementObserver.pause(callback)\n  }\n\n  stop() {\n    this.elementObserver.stop()\n  }\n\n  refresh() {\n    this.elementObserver.refresh()\n  }\n\n  get started(): boolean {\n    return this.elementObserver.started\n  }\n\n  // Element observer delegate\n\n  matchElement(element: Element): boolean {\n    return element.hasAttribute(this.attributeName)\n  }\n\n  matchElementsInTree(tree: Element): Element[] {\n    const match = this.matchElement(tree) ? [tree] : []\n    const matches = Array.from(tree.querySelectorAll(this.selector))\n    return match.concat(matches)\n  }\n\n  elementMatched(element: Element) {\n    if (this.delegate.elementMatchedAttribute) {\n      this.delegate.elementMatchedAttribute(element, this.attributeName)\n    }\n  }\n\n  elementUnmatched(element: Element) {\n    if (this.delegate.elementUnmatchedAttribute) {\n      this.delegate.elementUnmatchedAttribute(element, this.attributeName)\n    }\n  }\n\n  elementAttributeChanged(element: Element, attributeName: string) {\n    if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {\n      this.delegate.elementAttributeValueChanged(element, attributeName)\n    }\n  }\n}\n","export interface StringMapObserverDelegate {\n  getStringMapKeyForAttribute(attributeName: string): string | undefined\n  stringMapKeyAdded?(key: string, attributeName: string): void\n  stringMapValueChanged?(value: string | null, key: string, oldValue: string | null): void\n  stringMapKeyRemoved?(key: string, attributeName: string, oldValue: string | null): void\n}\n\nexport class StringMapObserver {\n  readonly element: Element\n  readonly delegate: StringMapObserverDelegate\n  private started: boolean\n  private stringMap: Map<string, string>\n  private mutationObserver: MutationObserver\n\n  constructor(element: Element, delegate: StringMapObserverDelegate) {\n    this.element = element\n    this.delegate = delegate\n    this.started = false\n    this.stringMap = new Map\n    this.mutationObserver = new MutationObserver(mutations => this.processMutations(mutations))\n  }\n\n  start() {\n    if (!this.started) {\n      this.started = true\n      this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true })\n      this.refresh()\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.mutationObserver.takeRecords()\n      this.mutationObserver.disconnect()\n      this.started = false\n    }\n  }\n\n  refresh() {\n    if (this.started) {\n      for (const attributeName of this.knownAttributeNames) {\n        this.refreshAttribute(attributeName, null)\n      }\n    }\n  }\n\n  // Mutation record processing\n\n  private processMutations(mutations: MutationRecord[]) {\n    if (this.started) {\n      for (const mutation of mutations) {\n        this.processMutation(mutation)\n      }\n    }\n  }\n\n  private processMutation(mutation: MutationRecord) {\n    const attributeName = mutation.attributeName\n    if (attributeName) {\n      this.refreshAttribute(attributeName, mutation.oldValue)\n    }\n  }\n\n  // State tracking\n\n  private refreshAttribute(attributeName: string, oldValue: string | null) {\n    const key = this.delegate.getStringMapKeyForAttribute(attributeName)\n    if (key != null) {\n      if (!this.stringMap.has(attributeName)) {\n        this.stringMapKeyAdded(key, attributeName)\n      }\n\n      const value = this.element.getAttribute(attributeName)\n      if (this.stringMap.get(attributeName) != value) {\n        this.stringMapValueChanged(value, key, oldValue)\n      }\n\n      if (value == null) {\n        const oldValue = this.stringMap.get(attributeName)\n        this.stringMap.delete(attributeName)\n        if (oldValue) this.stringMapKeyRemoved(key, attributeName, oldValue)\n      } else {\n        this.stringMap.set(attributeName, value)\n      }\n    }\n  }\n\n  private stringMapKeyAdded(key: string, attributeName: string) {\n    if (this.delegate.stringMapKeyAdded) {\n      this.delegate.stringMapKeyAdded(key, attributeName)\n    }\n  }\n\n  private stringMapValueChanged(value: string | null, key: string, oldValue: string | null) {\n    if (this.delegate.stringMapValueChanged) {\n      this.delegate.stringMapValueChanged(value, key, oldValue)\n    }\n  }\n\n  private stringMapKeyRemoved(key: string, attributeName: string, oldValue: string | null) {\n    if (this.delegate.stringMapKeyRemoved) {\n      this.delegate.stringMapKeyRemoved(key, attributeName, oldValue)\n    }\n  }\n\n  private get knownAttributeNames() {\n    return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)))\n  }\n\n  private get currentAttributeNames() {\n    return Array.from(this.element.attributes).map(attribute => attribute.name)\n  }\n\n  private get recordedAttributeNames() {\n    return Array.from(this.stringMap.keys())\n  }\n}\n","export function add<K, V>(map: Map<K, Set<V>>, key: K, value: V) {\n  fetch(map, key).add(value)\n}\n\nexport function del<K, V>(map: Map<K, Set<V>>, key: K, value: V) {\n  fetch(map, key).delete(value)\n  prune(map, key)\n}\n\nexport function fetch<K, V>(map: Map<K, Set<V>>, key: K): Set<V> {\n  let values = map.get(key)\n  if (!values) {\n    values = new Set()\n    map.set(key, values)\n  }\n  return values\n}\n\nexport function prune<K, V>(map: Map<K, Set<V>>, key: K) {\n  const values = map.get(key)\n  if (values != null && values.size == 0) {\n    map.delete(key)\n  }\n}\n","import { add, del } from \"./set_operations\"\n\nexport class Multimap<K, V> {\n  private valuesByKey: Map<K, Set<V>>\n\n  constructor() {\n    this.valuesByKey = new Map<K, Set<V>>()\n  }\n\n  get keys() {\n    return Array.from(this.valuesByKey.keys())\n  }\n\n  get values(): V[] {\n    const sets = Array.from(this.valuesByKey.values())\n    return sets.reduce((values, set) => values.concat(Array.from(set)), <V[]> [])\n  }\n\n  get size(): number {\n    const sets = Array.from(this.valuesByKey.values())\n    return sets.reduce((size, set) => size + set.size, 0)\n  }\n\n  add(key: K, value: V) {\n    add(this.valuesByKey, key, value)\n  }\n\n  delete(key: K, value: V) {\n    del(this.valuesByKey, key, value)\n  }\n\n  has(key: K, value: V): boolean {\n    const values = this.valuesByKey.get(key)\n    return values != null && values.has(value)\n  }\n\n  hasKey(key: K): boolean {\n    return this.valuesByKey.has(key)\n  }\n\n  hasValue(value: V): boolean {\n    const sets = Array.from(this.valuesByKey.values())\n    return sets.some(set => set.has(value))\n  }\n\n  getValuesForKey(key: K): V[] {\n    const values = this.valuesByKey.get(key)\n    return values ? Array.from(values) : []\n  }\n\n  getKeysForValue(value: V): K[] {\n    return Array.from(this.valuesByKey)\n      .filter(([key, values]) => values.has(value))\n      .map(([key, values]) => key)\n  }\n}\n","import { Multimap } from \"./multimap\"\nimport { add, del } from \"./set_operations\"\n\nexport class IndexedMultimap<K, V> extends Multimap<K, V> {\n  private keysByValue: Map<V, Set<K>>\n\n  constructor() {\n    super()\n    this.keysByValue = new Map\n  }\n\n  get values(): V[] {\n    return Array.from(this.keysByValue.keys())\n  }\n\n  add(key: K, value: V) {\n    super.add(key, value)\n    add(this.keysByValue, value, key)\n  }\n\n  delete(key: K, value: V) {\n    super.delete(key, value)\n    del(this.keysByValue, value, key)\n  }\n\n  hasValue(value: V): boolean {\n    return this.keysByValue.has(value)\n  }\n\n  getKeysForValue(value: V): K[] {\n    const set = this.keysByValue.get(value)\n    return set ? Array.from(set) : []\n  }\n}\n","import { AttributeObserver, AttributeObserverDelegate } from \"./attribute_observer\"\nimport { Multimap } from \"../multimap\"\n\nexport interface Token {\n  element: Element\n  attributeName: string\n  index: number\n  content: string\n}\n\nexport interface TokenListObserverDelegate {\n  tokenMatched(token: Token): void\n  tokenUnmatched(token: Token): void\n}\n\nexport class TokenListObserver implements AttributeObserverDelegate {\n  private attributeObserver: AttributeObserver\n  private delegate: TokenListObserverDelegate\n  private tokensByElement: Multimap<Element, Token>\n\n  constructor(element: Element, attributeName: string, delegate: TokenListObserverDelegate) {\n    this.attributeObserver = new AttributeObserver(element, attributeName, this)\n    this.delegate = delegate\n    this.tokensByElement = new Multimap\n  }\n\n  get started(): boolean {\n    return this.attributeObserver.started\n  }\n\n  start() {\n    this.attributeObserver.start()\n  }\n\n  pause(callback: () => void) {\n    this.attributeObserver.pause(callback)\n  }\n\n  stop() {\n    this.attributeObserver.stop()\n  }\n\n  refresh() {\n    this.attributeObserver.refresh()\n  }\n\n  get element(): Element {\n    return this.attributeObserver.element\n  }\n\n  get attributeName(): string {\n    return this.attributeObserver.attributeName\n  }\n\n  // Attribute observer delegate\n\n  elementMatchedAttribute(element: Element) {\n    this.tokensMatched(this.readTokensForElement(element))\n  }\n\n  elementAttributeValueChanged(element: Element) {\n    const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element)\n    this.tokensUnmatched(unmatchedTokens)\n    this.tokensMatched(matchedTokens)\n  }\n\n  elementUnmatchedAttribute(element: Element) {\n    this.tokensUnmatched(this.tokensByElement.getValuesForKey(element))\n  }\n\n  private tokensMatched(tokens: Token[]) {\n    tokens.forEach(token => this.tokenMatched(token))\n  }\n\n  private tokensUnmatched(tokens: Token[]) {\n    tokens.forEach(token => this.tokenUnmatched(token))\n  }\n\n  private tokenMatched(token: Token) {\n    this.delegate.tokenMatched(token)\n    this.tokensByElement.add(token.element, token)\n  }\n\n  private tokenUnmatched(token: Token) {\n    this.delegate.tokenUnmatched(token)\n    this.tokensByElement.delete(token.element, token)\n  }\n\n  private refreshTokensForElement(element: Element): [Token[], Token[]] {\n    const previousTokens = this.tokensByElement.getValuesForKey(element)\n    const currentTokens = this.readTokensForElement(element)\n    const firstDifferingIndex = zip(previousTokens, currentTokens)\n      .findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken))\n\n    if (firstDifferingIndex == -1) {\n      return [[], []]\n    } else {\n      return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)]\n    }\n  }\n\n  private readTokensForElement(element: Element): Token[] {\n    const attributeName = this.attributeName\n    const tokenString = element.getAttribute(attributeName) || \"\"\n    return parseTokenString(tokenString, element, attributeName)\n  }\n}\n\nfunction parseTokenString(tokenString: string, element: Element, attributeName: string): Token[] {\n  return tokenString.trim().split(/\\s+/).filter(content => content.length)\n    .map((content, index) => ({ element, attributeName, content, index }))\n}\n\nfunction zip<L, R>(left: L[], right: R[]): [L | undefined, R | undefined][] {\n  const length = Math.max(left.length, right.length)\n  return Array.from({ length }, (_, index) => [left[index], right[index]] as [L, R])\n}\n\nfunction tokensAreEqual(left?: Token, right?: Token) {\n  return left && right && left.index == right.index && left.content == right.content\n}\n","import { Token, TokenListObserver, TokenListObserverDelegate } from \"./token_list_observer\"\n\nexport interface ValueListObserverDelegate<T> {\n  parseValueForToken(token: Token): T | undefined\n  elementMatchedValue(element: Element, value: T): void\n  elementUnmatchedValue(element: Element, value: T): void\n}\n\ninterface ParseResult<T> {\n  value?: T\n  error?: Error\n}\n\nexport class ValueListObserver<T> implements TokenListObserverDelegate {\n  private tokenListObserver: TokenListObserver\n  private delegate: ValueListObserverDelegate<T>\n  private parseResultsByToken: WeakMap<Token, ParseResult<T>>\n  private valuesByTokenByElement: WeakMap<Element, Map<Token, T>>\n\n  constructor(element: Element, attributeName: string, delegate: ValueListObserverDelegate<T>) {\n    this.tokenListObserver = new TokenListObserver(element, attributeName, this)\n    this.delegate = delegate\n    this.parseResultsByToken = new WeakMap\n    this.valuesByTokenByElement = new WeakMap\n  }\n\n  get started(): boolean {\n    return this.tokenListObserver.started\n  }\n\n  start() {\n    this.tokenListObserver.start()\n  }\n\n  stop() {\n    this.tokenListObserver.stop()\n  }\n\n  refresh() {\n    this.tokenListObserver.refresh()\n  }\n\n  get element(): Element {\n    return this.tokenListObserver.element\n  }\n\n  get attributeName(): string {\n    return this.tokenListObserver.attributeName\n  }\n\n  tokenMatched(token: Token) {\n    const { element } = token\n    const { value } = this.fetchParseResultForToken(token)\n    if (value) {\n      this.fetchValuesByTokenForElement(element).set(token, value)\n      this.delegate.elementMatchedValue(element, value)\n    }\n  }\n\n  tokenUnmatched(token: Token) {\n    const { element } = token\n    const { value } = this.fetchParseResultForToken(token)\n    if (value) {\n      this.fetchValuesByTokenForElement(element).delete(token)\n      this.delegate.elementUnmatchedValue(element, value)\n    }\n  }\n\n  private fetchParseResultForToken(token: Token) {\n    let parseResult = this.parseResultsByToken.get(token)\n    if (!parseResult) {\n      parseResult = this.parseToken(token)\n      this.parseResultsByToken.set(token, parseResult)\n    }\n    return parseResult\n  }\n\n  private fetchValuesByTokenForElement(element: Element) {\n    let valuesByToken = this.valuesByTokenByElement.get(element)\n    if (!valuesByToken) {\n      valuesByToken = new Map\n      this.valuesByTokenByElement.set(element, valuesByToken)\n    }\n    return valuesByToken\n  }\n\n  private parseToken(token: Token): ParseResult<T> {\n    try {\n      const value = this.delegate.parseValueForToken(token)\n      return { value }\n    } catch (error) {\n      return { error }\n    }\n  }\n}\n","import { Action } from \"./action\"\nimport { Binding } from \"./binding\"\nimport { Context } from \"./context\"\nimport { ErrorHandler } from \"./error_handler\"\nimport { Schema } from \"./schema\"\nimport { Token, ValueListObserver, ValueListObserverDelegate } from \"../mutation-observers\"\n\nexport interface BindingObserverDelegate extends ErrorHandler {\n  bindingConnected(binding: Binding): void\n  bindingDisconnected(binding: Binding): void\n}\n\nexport class BindingObserver implements ValueListObserverDelegate<Action> {\n  readonly context: Context\n  private delegate: BindingObserverDelegate\n  private valueListObserver?: ValueListObserver<Action>\n  private bindingsByAction: Map<Action, Binding>\n\n  constructor(context: Context, delegate: BindingObserverDelegate) {\n    this.context = context\n    this.delegate = delegate\n    this.bindingsByAction = new Map\n  }\n\n  start() {\n    if (!this.valueListObserver) {\n      this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this)\n      this.valueListObserver.start()\n    }\n  }\n\n  stop() {\n    if (this.valueListObserver) {\n      this.valueListObserver.stop()\n      delete this.valueListObserver\n      this.disconnectAllActions()\n    }\n  }\n\n  get element() {\n    return this.context.element\n  }\n\n  get identifier() {\n    return this.context.identifier\n  }\n\n  get actionAttribute() {\n    return this.schema.actionAttribute\n  }\n\n  get schema(): Schema {\n    return this.context.schema\n  }\n\n  get bindings(): Binding[] {\n    return Array.from(this.bindingsByAction.values())\n  }\n\n  private connectAction(action: Action) {\n    const binding = new Binding(this.context, action)\n    this.bindingsByAction.set(action, binding)\n    this.delegate.bindingConnected(binding)\n  }\n\n  private disconnectAction(action: Action) {\n    const binding = this.bindingsByAction.get(action)\n    if (binding) {\n      this.bindingsByAction.delete(action)\n      this.delegate.bindingDisconnected(binding)\n    }\n  }\n\n  private disconnectAllActions() {\n    this.bindings.forEach(binding => this.delegate.bindingDisconnected(binding))\n    this.bindingsByAction.clear()\n  }\n\n  // Value observer delegate\n\n  parseValueForToken(token: Token): Action | undefined {\n    const action = Action.forToken(token)\n    if (action.identifier == this.identifier) {\n      return action\n    }\n  }\n\n  elementMatchedValue(element: Element, action: Action) {\n    this.connectAction(action)\n  }\n\n  elementUnmatchedValue(element: Element, action: Action) {\n    this.disconnectAction(action)\n  }\n}\n","import { Context } from \"./context\"\nimport { StringMapObserver, StringMapObserverDelegate } from \"../mutation-observers\"\nimport { ValueDescriptor } from \"./value_properties\"\nimport { capitalize } from \"./string_helpers\"\n\nexport class ValueObserver implements StringMapObserverDelegate {\n  readonly context: Context\n  readonly receiver: any\n  private stringMapObserver: StringMapObserver\n  private valueDescriptorMap: { [attributeName: string]: ValueDescriptor }\n\n  constructor(context: Context, receiver: any) {\n    this.context = context\n    this.receiver = receiver\n    this.stringMapObserver = new StringMapObserver(this.element, this)\n    this.valueDescriptorMap = (this.controller as any).valueDescriptorMap\n  }\n\n  start() {\n    this.stringMapObserver.start()\n    this.invokeChangedCallbacksForDefaultValues()\n  }\n\n  stop() {\n    this.stringMapObserver.stop()\n  }\n\n  get element() {\n    return this.context.element\n  }\n\n  get controller() {\n    return this.context.controller\n  }\n\n  // String map observer delegate\n\n  getStringMapKeyForAttribute(attributeName: string) {\n    if (attributeName in this.valueDescriptorMap) {\n      return this.valueDescriptorMap[attributeName].name\n    }\n  }\n\n  stringMapKeyAdded(key: string, attributeName: string) {\n    const descriptor = this.valueDescriptorMap[attributeName]\n\n    if (!this.hasValue(key)) {\n      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue))\n    }\n  }\n\n  stringMapValueChanged(value: string, name: string, oldValue: string) {\n    const descriptor = this.valueDescriptorNameMap[name]\n\n    if (value === null) return\n\n    if (oldValue === null) {\n      oldValue = descriptor.writer(descriptor.defaultValue)\n    }\n\n    this.invokeChangedCallback(name, value, oldValue)\n  }\n\n  stringMapKeyRemoved(key: string, attributeName: string, oldValue: string) {\n    const descriptor = this.valueDescriptorNameMap[key]\n\n    if (this.hasValue(key)) {\n      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue)\n    } else {\n      this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue)\n    }\n  }\n\n  private invokeChangedCallbacksForDefaultValues() {\n    for (const { key, name, defaultValue, writer } of this.valueDescriptors) {\n      if (defaultValue != undefined && !this.controller.data.has(key)) {\n        this.invokeChangedCallback(name, writer(defaultValue), undefined)\n      }\n    }\n  }\n\n  private invokeChangedCallback(name: string, rawValue: string, rawOldValue: string | undefined) {\n    const changedMethodName = `${name}Changed`\n    const changedMethod = this.receiver[changedMethodName]\n\n    if (typeof changedMethod == \"function\") {\n      const descriptor = this.valueDescriptorNameMap[name]\n\n      try {\n        const value = descriptor.reader(rawValue)\n        let oldValue = rawOldValue\n\n        if (rawOldValue) {\n          oldValue = descriptor.reader(rawOldValue)\n        }\n\n        changedMethod.call(this.receiver, value, oldValue)\n      } catch (error) {\n        if (!(error instanceof TypeError)) throw error\n\n        throw new TypeError(`Stimulus Value \"${this.context.identifier}.${descriptor.name}\" - ${error.message}`)\n      }\n    }\n  }\n\n  private get valueDescriptors() {\n    const { valueDescriptorMap } = this\n    return Object.keys(valueDescriptorMap).map(key => valueDescriptorMap[key])\n  }\n\n  private get valueDescriptorNameMap() {\n    const descriptors: { [type: string]: ValueDescriptor }  = {}\n\n    Object.keys(this.valueDescriptorMap).forEach(key => {\n      const descriptor = this.valueDescriptorMap[key]\n      descriptors[descriptor.name] = descriptor\n    })\n\n    return descriptors\n  }\n\n  private hasValue(attributeName: string) {\n    const descriptor = this.valueDescriptorNameMap[attributeName]\n    const hasMethodName = `has${capitalize(descriptor.name)}`\n\n    return this.receiver[hasMethodName]\n  }\n}\n","import { Multimap } from \"../multimap\"\nimport { Token, TokenListObserver, TokenListObserverDelegate } from \"../mutation-observers\"\nimport { Context } from \"./context\"\n\nexport interface TargetObserverDelegate {\n  targetConnected(element: Element, name: string): void\n  targetDisconnected(element: Element, name: string): void\n}\n\nexport class TargetObserver implements TokenListObserverDelegate {\n  readonly context: Context\n  readonly delegate: TargetObserverDelegate\n  readonly targetsByName: Multimap<string, Element>\n  private tokenListObserver?: TokenListObserver\n\n  constructor(context: Context, delegate: TargetObserverDelegate) {\n    this.context = context\n    this.delegate = delegate\n    this.targetsByName = new Multimap\n  }\n\n  start() {\n    if (!this.tokenListObserver) {\n      this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this)\n      this.tokenListObserver.start()\n    }\n  }\n\n  stop() {\n    if (this.tokenListObserver) {\n      this.disconnectAllTargets()\n      this.tokenListObserver.stop()\n      delete this.tokenListObserver\n    }\n  }\n\n  // Token list observer delegate\n\n  tokenMatched({ element, content: name }: Token) {\n    if (this.scope.containsElement(element)) {\n      this.connectTarget(element, name)\n    }\n  }\n\n  tokenUnmatched({ element, content: name }: Token) {\n    this.disconnectTarget(element, name)\n  }\n\n  // Target management\n\n  connectTarget(element: Element, name: string) {\n    if (!this.targetsByName.has(name, element)) {\n      this.targetsByName.add(name, element)\n      this.tokenListObserver?.pause(() => this.delegate.targetConnected(element, name))\n    }\n  }\n\n  disconnectTarget(element: Element, name: string) {\n    if (this.targetsByName.has(name, element)) {\n      this.targetsByName.delete(name, element)\n      this.tokenListObserver?.pause(() => this.delegate.targetDisconnected(element, name))\n    }\n  }\n\n  disconnectAllTargets() {\n    for (const name of this.targetsByName.keys) {\n      for (const element of this.targetsByName.getValuesForKey(name)) {\n        this.disconnectTarget(element, name)\n      }\n    }\n  }\n\n  // Private\n\n  private get attributeName() {\n    return `data-${this.context.identifier}-target`\n  }\n\n  private get element() {\n    return this.context.element\n  }\n\n  private get scope() {\n    return this.context.scope\n  }\n}\n","import { Application } from \"./application\"\nimport { BindingObserver } from \"./binding_observer\"\nimport { Controller } from \"./controller\"\nimport { Dispatcher } from \"./dispatcher\"\nimport { ErrorHandler } from \"./error_handler\"\nimport { Module } from \"./module\"\nimport { Schema } from \"./schema\"\nimport { Scope } from \"./scope\"\nimport { ValueObserver } from \"./value_observer\"\nimport { TargetObserver, TargetObserverDelegate } from \"./target_observer\"\n\nexport class Context implements ErrorHandler, TargetObserverDelegate {\n  readonly module: Module\n  readonly scope: Scope\n  readonly controller: Controller\n  private bindingObserver: BindingObserver\n  private valueObserver: ValueObserver\n  private targetObserver: TargetObserver\n\n  constructor(module: Module, scope: Scope) {\n    this.module = module\n    this.scope = scope\n    this.controller = new module.controllerConstructor(this)\n    this.bindingObserver = new BindingObserver(this, this.dispatcher)\n    this.valueObserver = new ValueObserver(this, this.controller)\n    this.targetObserver = new TargetObserver(this, this)\n\n    try {\n      this.controller.initialize()\n      this.logDebugActivity(\"initialize\")\n    } catch (error) {\n      this.handleError(error, \"initializing controller\")\n    }\n  }\n\n  connect() {\n    this.bindingObserver.start()\n    this.valueObserver.start()\n    this.targetObserver.start()\n\n    try {\n      this.controller.connect()\n      this.logDebugActivity(\"connect\")\n    } catch (error) {\n      this.handleError(error, \"connecting controller\")\n    }\n  }\n\n  disconnect() {\n    try {\n      this.controller.disconnect()\n      this.logDebugActivity(\"disconnect\")\n    } catch (error) {\n      this.handleError(error, \"disconnecting controller\")\n    }\n\n    this.targetObserver.stop()\n    this.valueObserver.stop()\n    this.bindingObserver.stop()\n  }\n\n  get application(): Application {\n    return this.module.application\n  }\n\n  get identifier(): string {\n    return this.module.identifier\n  }\n\n  get schema(): Schema {\n    return this.application.schema\n  }\n\n  get dispatcher(): Dispatcher {\n    return this.application.dispatcher\n  }\n\n  get element(): Element {\n    return this.scope.element\n  }\n\n  get parentElement(): Element | null {\n    return this.element.parentElement\n  }\n\n  // Error handling\n\n  handleError(error: Error, message: string, detail: object = {}) {\n    const { identifier, controller, element } = this\n    detail = Object.assign({ identifier, controller, element }, detail)\n    this.application.handleError(error, `Error ${message}`, detail)\n  }\n\n  // Debug logging\n\n  logDebugActivity = (functionName: string, detail: object = {}): void => {\n    const { identifier, controller, element } = this\n    detail = Object.assign({ identifier, controller, element }, detail)\n    this.application.logDebugActivity(this.identifier, functionName, detail)\n  }\n\n  // Target observer delegate\n\n  targetConnected(element: Element, name: string) {\n    this.invokeControllerMethod(`${name}TargetConnected`, element)\n  }\n\n  targetDisconnected(element: Element, name: string) {\n    this.invokeControllerMethod(`${name}TargetDisconnected`, element)\n  }\n\n  // Private\n\n  invokeControllerMethod(methodName: string, ...args: any[]) {\n    const controller: any = this.controller\n    if (typeof controller[methodName] == \"function\") {\n      controller[methodName](...args)\n    }\n  }\n}\n","import { Constructor } from \"./constructor\"\n\nexport function readInheritableStaticArrayValues<T, U = string>(constructor: Constructor<T>, propertyName: string) {\n  const ancestors = getAncestorsForConstructor(constructor)\n  return Array.from(ancestors.reduce((values, constructor) => {\n    getOwnStaticArrayValues(constructor, propertyName).forEach(name => values.add(name))\n    return values\n  }, new Set as Set<U>))\n}\n\nexport function readInheritableStaticObjectPairs<T, U>(constructor: Constructor<T>, propertyName: string) {\n  const ancestors = getAncestorsForConstructor(constructor)\n  return ancestors.reduce((pairs, constructor) => {\n    pairs.push(...getOwnStaticObjectPairs(constructor, propertyName) as any)\n    return pairs\n  }, [] as [string, U][])\n}\n\nfunction getAncestorsForConstructor<T>(constructor: Constructor<T>) {\n  const ancestors: Constructor<{}>[] = []\n  while (constructor) {\n    ancestors.push(constructor)\n    constructor = Object.getPrototypeOf(constructor)\n  }\n  return ancestors.reverse()\n}\n\nfunction getOwnStaticArrayValues<T>(constructor: Constructor<T>, propertyName: string) {\n  const definition = (constructor as any)[propertyName]\n  return Array.isArray(definition) ? definition : []\n}\n\nfunction getOwnStaticObjectPairs<T, U>(constructor: Constructor<T>, propertyName: string) {\n  const definition = (constructor as any)[propertyName]\n  return definition ? Object.keys(definition).map(key => [key, definition[key]] as [string, U]) : []\n}\n","import { Constructor } from \"./constructor\"\nimport { readInheritableStaticArrayValues } from \"./inheritable_statics\"\n\nexport type Blessing<T> = (constructor: Constructor<T>) => PropertyDescriptorMap\n\nexport interface Blessable<T> extends Constructor<T> {\n  readonly blessings?: Blessing<T>[]\n}\n\nexport function bless<T>(constructor: Blessable<T>): Constructor<T> {\n  return shadow(constructor, getBlessedProperties(constructor))\n}\n\nfunction shadow<T>(constructor: Constructor<T>, properties: PropertyDescriptorMap) {\n  const shadowConstructor = extend(constructor)\n  const shadowProperties = getShadowProperties(constructor.prototype, properties)\n  Object.defineProperties(shadowConstructor.prototype, shadowProperties)\n  return shadowConstructor\n}\n\nfunction getBlessedProperties<T>(constructor: Constructor<T>) {\n  const blessings = readInheritableStaticArrayValues(constructor, \"blessings\") as Blessing<T>[]\n  return blessings.reduce((blessedProperties, blessing) => {\n    const properties = blessing(constructor)\n    for (const key in properties) {\n      const descriptor = blessedProperties[key] || {} as PropertyDescriptor\n      blessedProperties[key] = Object.assign(descriptor, properties[key])\n    }\n    return blessedProperties\n  }, {} as PropertyDescriptorMap)\n}\n\nfunction getShadowProperties<T>(prototype: any, properties: PropertyDescriptorMap) {\n  return getOwnKeys(properties).reduce((shadowProperties, key) => {\n    const descriptor = getShadowedDescriptor(prototype, properties, key)\n    if (descriptor) {\n      Object.assign(shadowProperties, { [key]: descriptor })\n    }\n    return shadowProperties\n  }, {} as PropertyDescriptorMap)\n}\n\nfunction getShadowedDescriptor(prototype: any, properties: PropertyDescriptorMap, key: string | symbol) {\n  const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key)\n  const shadowedByValue = shadowingDescriptor && \"value\" in shadowingDescriptor\n  if (!shadowedByValue) {\n    const descriptor = Object.getOwnPropertyDescriptor(properties, key)!.value\n    if (shadowingDescriptor) {\n      descriptor.get = shadowingDescriptor.get || descriptor.get\n      descriptor.set = shadowingDescriptor.set || descriptor.set\n    }\n    return descriptor\n  }\n}\n\nconst getOwnKeys = (() => {\n  if (typeof Object.getOwnPropertySymbols == \"function\") {\n    return (object: any) => [\n      ...Object.getOwnPropertyNames(object),\n      ...Object.getOwnPropertySymbols(object)\n    ]\n  } else {\n    return Object.getOwnPropertyNames\n  }\n})()\n\nconst extend = (() => {\n  function extendWithReflect<T extends Constructor<{}>>(constructor: T): T {\n    function extended() {\n      return Reflect.construct(constructor, arguments, new.target)\n    }\n\n    extended.prototype = Object.create(constructor.prototype, {\n      constructor: { value: extended }\n    })\n\n    Reflect.setPrototypeOf(extended, constructor)\n    return extended as any\n  }\n\n  function testReflectExtension() {\n    const a = function(this: any) { this.a.call(this) } as any\n    const b = extendWithReflect(a)\n    b.prototype.a = function() {}\n    return new b\n  }\n\n  try {\n    testReflectExtension()\n    return extendWithReflect\n  } catch (error) {\n    return <T extends Constructor<{}>>(constructor: T) => class extended extends constructor {}\n  }\n})()\n","import { Application } from \"./application\"\nimport { Context } from \"./context\"\nimport { ControllerConstructor } from \"./controller\"\nimport { Definition, blessDefinition } from \"./definition\"\nimport { Scope } from \"./scope\"\n\nexport class Module {\n  readonly application: Application\n  readonly definition: Definition\n  private contextsByScope: WeakMap<Scope, Context>\n  private connectedContexts: Set<Context>\n\n  constructor(application: Application, definition: Definition) {\n    this.application = application\n    this.definition = blessDefinition(definition)\n    this.contextsByScope = new WeakMap\n    this.connectedContexts = new Set\n  }\n\n  get identifier(): string {\n    return this.definition.identifier\n  }\n\n  get controllerConstructor(): ControllerConstructor {\n    return this.definition.controllerConstructor\n  }\n\n  get contexts(): Context[] {\n    return Array.from(this.connectedContexts)\n  }\n\n  connectContextForScope(scope: Scope) {\n    const context = this.fetchContextForScope(scope)\n    this.connectedContexts.add(context)\n    context.connect()\n  }\n\n  disconnectContextForScope(scope: Scope) {\n    const context = this.contextsByScope.get(scope)\n    if (context) {\n      this.connectedContexts.delete(context)\n      context.disconnect()\n    }\n  }\n\n  private fetchContextForScope(scope: Scope): Context {\n    let context = this.contextsByScope.get(scope)\n    if (!context) {\n      context = new Context(this, scope)\n      this.contextsByScope.set(scope, context)\n    }\n    return context\n  }\n}\n","import { bless } from \"./blessing\"\nimport { ControllerConstructor } from \"./controller\"\n\nexport interface Definition {\n  identifier: string\n  controllerConstructor: ControllerConstructor\n}\n\nexport function blessDefinition(definition: Definition): Definition {\n  return {\n    identifier: definition.identifier,\n    controllerConstructor: bless(definition.controllerConstructor)\n  }\n}\n","import { Scope } from \"./scope\"\nimport { tokenize } from \"./string_helpers\"\n\nexport class ClassMap {\n  readonly scope: Scope\n\n  constructor(scope: Scope) {\n    this.scope = scope\n  }\n\n  has(name: string) {\n    return this.data.has(this.getDataKey(name))\n  }\n\n  get(name: string): string | undefined {\n    return this.getAll(name)[0]\n  }\n\n  getAll(name: string) {\n    const tokenString = this.data.get(this.getDataKey(name)) || \"\"\n    return tokenize(tokenString)\n  }\n\n  getAttributeName(name: string) {\n    return this.data.getAttributeNameForKey(this.getDataKey(name))\n  }\n\n  getDataKey(name: string) {\n    return `${name}-class`\n  }\n\n  get data() {\n    return this.scope.data\n  }\n}\n","import { Scope } from \"./scope\"\nimport { dasherize } from \"./string_helpers\"\n\nexport class DataMap {\n  readonly scope: Scope\n\n  constructor(scope: Scope) {\n    this.scope = scope\n  }\n\n  get element(): Element {\n    return this.scope.element\n  }\n\n  get identifier(): string {\n    return this.scope.identifier\n  }\n\n  get(key: string): string | null {\n    const name = this.getAttributeNameForKey(key)\n    return this.element.getAttribute(name)\n  }\n\n  set(key: string, value: string): string | null {\n    const name = this.getAttributeNameForKey(key)\n    this.element.setAttribute(name, value)\n    return this.get(key)\n  }\n\n  has(key: string): boolean {\n    const name = this.getAttributeNameForKey(key)\n    return this.element.hasAttribute(name)\n  }\n\n  delete(key: string): boolean {\n    if (this.has(key)) {\n      const name = this.getAttributeNameForKey(key)\n      this.element.removeAttribute(name)\n      return true\n    } else {\n      return false\n    }\n  }\n\n  getAttributeNameForKey(key: string): string {\n    return `data-${this.identifier}-${dasherize(key)}`\n  }\n}\n","import { Logger } from \"./logger\"\n\nexport class Guide {\n  readonly logger: Logger\n  readonly warnedKeysByObject: WeakMap<any, Set<string>> = new WeakMap\n\n  constructor(logger: Logger) {\n    this.logger = logger\n  }\n\n  warn(object: any, key: string, message: string) {\n    let warnedKeys: Set<string> | undefined = this.warnedKeysByObject.get(object)\n\n    if (!warnedKeys) {\n      warnedKeys = new Set\n      this.warnedKeysByObject.set(object, warnedKeys)\n    }\n\n    if (!warnedKeys.has(key)) {\n      warnedKeys.add(key)\n      this.logger.warn(message, object)\n    }\n  }\n}\n","export function attributeValueContainsToken(attributeName: string, token: string) {\n  return `[${attributeName}~=\"${token}\"]`\n}\n","import { Scope } from \"./scope\"\nimport { attributeValueContainsToken } from \"./selectors\"\n\nexport class TargetSet {\n  readonly scope: Scope\n\n  constructor(scope: Scope) {\n    this.scope = scope\n  }\n\n  get element() {\n    return this.scope.element\n  }\n\n  get identifier() {\n    return this.scope.identifier\n  }\n\n  get schema() {\n    return this.scope.schema\n  }\n\n  has(targetName: string) {\n    return this.find(targetName) != null\n  }\n\n  find(...targetNames: string[]) {\n    return targetNames.reduce((target, targetName) =>\n         target\n      || this.findTarget(targetName)\n      || this.findLegacyTarget(targetName)\n    , undefined as Element | undefined)\n  }\n\n  findAll(...targetNames: string[]) {\n    return targetNames.reduce((targets, targetName) => [\n      ...targets,\n      ...this.findAllTargets(targetName),\n      ...this.findAllLegacyTargets(targetName)\n    ], [] as Element[])\n  }\n\n  private findTarget(targetName: string) {\n    const selector = this.getSelectorForTargetName(targetName)\n    return this.scope.findElement(selector)\n  }\n\n  private findAllTargets(targetName: string) {\n    const selector = this.getSelectorForTargetName(targetName)\n    return this.scope.findAllElements(selector)\n  }\n\n  private getSelectorForTargetName(targetName: string) {\n    const attributeName = this.schema.targetAttributeForScope(this.identifier)\n    return attributeValueContainsToken(attributeName, targetName)\n  }\n\n  private findLegacyTarget(targetName: string) {\n    const selector = this.getLegacySelectorForTargetName(targetName)\n    return this.deprecate(this.scope.findElement(selector), targetName)\n  }\n\n  private findAllLegacyTargets(targetName: string) {\n    const selector = this.getLegacySelectorForTargetName(targetName)\n    return this.scope.findAllElements(selector).map(element => this.deprecate(element, targetName))\n  }\n\n  private getLegacySelectorForTargetName(targetName: string) {\n    const targetDescriptor = `${this.identifier}.${targetName}`\n    return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor)\n  }\n\n  private deprecate<T>(element: T, targetName: string) {\n    if (element) {\n      const { identifier } = this\n      const attributeName = this.schema.targetAttribute\n      const revisedAttributeName = this.schema.targetAttributeForScope(identifier)\n      this.guide.warn(element, `target:${targetName}`,\n        `Please replace ${attributeName}=\"${identifier}.${targetName}\" with ${revisedAttributeName}=\"${targetName}\". ` +\n        `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`)\n    }\n    return element\n  }\n\n  private get guide() {\n    return this.scope.guide\n  }\n}\n","import { ClassMap } from \"./class_map\"\nimport { DataMap } from \"./data_map\"\nimport { Guide } from \"./guide\"\nimport { Logger } from \"./logger\"\nimport { Schema } from \"./schema\"\nimport { attributeValueContainsToken } from \"./selectors\"\nimport { TargetSet } from \"./target_set\"\n\nexport class Scope {\n  readonly schema: Schema\n  readonly element: Element\n  readonly identifier: string\n  readonly guide: Guide\n  readonly targets = new TargetSet(this)\n  readonly classes = new ClassMap(this)\n  readonly data = new DataMap(this)\n\n  constructor(schema: Schema, element: Element, identifier: string, logger: Logger) {\n    this.schema = schema\n    this.element = element\n    this.identifier = identifier\n    this.guide = new Guide(logger)\n  }\n\n  findElement(selector: string): Element | undefined {\n    return this.element.matches(selector)\n      ? this.element\n      : this.queryElements(selector).find(this.containsElement)\n  }\n\n  findAllElements(selector: string): Element[] {\n    return [\n      ...this.element.matches(selector) ? [this.element] : [],\n      ...this.queryElements(selector).filter(this.containsElement)\n    ]\n  }\n\n  containsElement = (element: Element): boolean => {\n    return element.closest(this.controllerSelector) === this.element\n  }\n\n  private queryElements(selector: string): Element[] {\n    return Array.from(this.element.querySelectorAll(selector))\n  }\n\n  private get controllerSelector(): string {\n    return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier)\n  }\n}\n","import { ErrorHandler } from \"./error_handler\"\nimport { Schema } from \"./schema\"\nimport { Scope } from \"./scope\"\nimport { Token, ValueListObserver, ValueListObserverDelegate } from \"../mutation-observers\"\n\nexport interface ScopeObserverDelegate extends ErrorHandler {\n  createScopeForElementAndIdentifier(element: Element, identifier: string): Scope\n  scopeConnected(scope: Scope): void\n  scopeDisconnected(scope: Scope): void\n}\n\nexport class ScopeObserver implements ValueListObserverDelegate<Scope> {\n  readonly element: Element\n  readonly schema: Schema\n  private delegate: ScopeObserverDelegate\n  private valueListObserver: ValueListObserver<Scope>\n  private scopesByIdentifierByElement: WeakMap<Element, Map<string, Scope>>\n  private scopeReferenceCounts: WeakMap<Scope, number>\n\n  constructor(element: Element, schema: Schema, delegate: ScopeObserverDelegate) {\n    this.element = element\n    this.schema = schema\n    this.delegate = delegate\n    this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this)\n    this.scopesByIdentifierByElement = new WeakMap\n    this.scopeReferenceCounts = new WeakMap\n  }\n\n  start() {\n    this.valueListObserver.start()\n  }\n\n  stop() {\n    this.valueListObserver.stop()\n  }\n\n  get controllerAttribute() {\n    return this.schema.controllerAttribute\n  }\n\n  // Value observer delegate\n\n  parseValueForToken(token: Token): Scope | undefined {\n    const { element, content: identifier } = token\n    const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element)\n\n    let scope = scopesByIdentifier.get(identifier)\n    if (!scope) {\n      scope = this.delegate.createScopeForElementAndIdentifier(element, identifier)\n      scopesByIdentifier.set(identifier, scope)\n    }\n\n    return scope\n  }\n\n  elementMatchedValue(element: Element, value: Scope) {\n    const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1\n    this.scopeReferenceCounts.set(value, referenceCount)\n    if (referenceCount == 1) {\n      this.delegate.scopeConnected(value)\n    }\n  }\n\n  elementUnmatchedValue(element: Element, value: Scope) {\n    const referenceCount = this.scopeReferenceCounts.get(value)\n    if (referenceCount) {\n      this.scopeReferenceCounts.set(value, referenceCount - 1)\n      if (referenceCount == 1) {\n        this.delegate.scopeDisconnected(value)\n      }\n    }\n  }\n\n  private fetchScopesByIdentifierForElement(element: Element) {\n    let scopesByIdentifier = this.scopesByIdentifierByElement.get(element)\n    if (!scopesByIdentifier) {\n      scopesByIdentifier = new Map\n      this.scopesByIdentifierByElement.set(element, scopesByIdentifier)\n    }\n    return scopesByIdentifier\n  }\n}\n","import { Application } from \"./application\"\nimport { Context } from \"./context\"\nimport { Definition } from \"./definition\"\nimport { Module } from \"./module\"\nimport { Multimap } from \"../multimap\"\nimport { Scope } from \"./scope\"\nimport { ScopeObserver, ScopeObserverDelegate } from \"./scope_observer\"\n\nexport class Router implements ScopeObserverDelegate {\n  readonly application: Application\n  private scopeObserver: ScopeObserver\n  private scopesByIdentifier: Multimap<string, Scope>\n  private modulesByIdentifier: Map<string, Module>\n\n  constructor(application: Application) {\n    this.application = application\n    this.scopeObserver = new ScopeObserver(this.element, this.schema, this)\n    this.scopesByIdentifier = new Multimap\n    this.modulesByIdentifier = new Map\n  }\n\n  get element() {\n    return this.application.element\n  }\n\n  get schema() {\n    return this.application.schema\n  }\n\n  get logger() {\n    return this.application.logger\n  }\n\n  get controllerAttribute(): string {\n    return this.schema.controllerAttribute\n  }\n\n  get modules() {\n    return Array.from(this.modulesByIdentifier.values())\n  }\n\n  get contexts() {\n    return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), [] as Context[])\n  }\n\n  start() {\n    this.scopeObserver.start()\n  }\n\n  stop() {\n    this.scopeObserver.stop()\n  }\n\n  loadDefinition(definition: Definition) {\n    this.unloadIdentifier(definition.identifier)\n    const module = new Module(this.application, definition)\n    this.connectModule(module)\n  }\n\n  unloadIdentifier(identifier: string) {\n    const module = this.modulesByIdentifier.get(identifier)\n    if (module) {\n      this.disconnectModule(module)\n    }\n  }\n\n  getContextForElementAndIdentifier(element: Element, identifier: string) {\n    const module = this.modulesByIdentifier.get(identifier)\n    if (module) {\n      return module.contexts.find(context => context.element == element)\n    }\n  }\n\n  // Error handler delegate\n\n  handleError(error: Error, message: string, detail: any) {\n    this.application.handleError(error, message, detail)\n  }\n\n  // Scope observer delegate\n\n  createScopeForElementAndIdentifier(element: Element, identifier: string) {\n    return new Scope(this.schema, element, identifier, this.logger)\n  }\n\n  scopeConnected(scope: Scope) {\n    this.scopesByIdentifier.add(scope.identifier, scope)\n    const module = this.modulesByIdentifier.get(scope.identifier)\n    if (module) {\n      module.connectContextForScope(scope)\n    }\n  }\n\n  scopeDisconnected(scope: Scope) {\n    this.scopesByIdentifier.delete(scope.identifier, scope)\n    const module = this.modulesByIdentifier.get(scope.identifier)\n    if (module) {\n      module.disconnectContextForScope(scope)\n    }\n  }\n\n  // Modules\n\n  private connectModule(module: Module) {\n    this.modulesByIdentifier.set(module.identifier, module)\n    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier)\n    scopes.forEach(scope => module.connectContextForScope(scope))\n  }\n\n  private disconnectModule(module: Module) {\n    this.modulesByIdentifier.delete(module.identifier)\n    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier)\n    scopes.forEach(scope => module.disconnectContextForScope(scope))\n  }\n}\n","export interface Schema {\n  controllerAttribute: string\n  actionAttribute: string\n  targetAttribute: string\n  targetAttributeForScope(identifier: string): string\n}\n\nexport const defaultSchema: Schema = {\n  controllerAttribute: \"data-controller\",\n  actionAttribute: \"data-action\",\n  targetAttribute: \"data-target\",\n  targetAttributeForScope: identifier => `data-${identifier}-target`\n}\n","import { Controller, ControllerConstructor } from \"./controller\"\nimport { Definition } from \"./definition\"\nimport { Dispatcher } from \"./dispatcher\"\nimport { ErrorHandler } from \"./error_handler\"\nimport { Logger } from \"./logger\"\nimport { Router } from \"./router\"\nimport { Schema, defaultSchema } from \"./schema\"\n\nexport class Application implements ErrorHandler {\n  readonly element: Element\n  readonly schema: Schema\n  readonly dispatcher: Dispatcher\n  readonly router: Router\n  logger: Logger = console\n  debug: boolean = false\n\n  static start(element?: Element, schema?: Schema): Application {\n    const application = new Application(element, schema)\n    application.start()\n    return application\n  }\n\n  constructor(element: Element = document.documentElement, schema: Schema = defaultSchema) {\n    this.element = element\n    this.schema = schema\n    this.dispatcher = new Dispatcher(this)\n    this.router = new Router(this)\n  }\n\n  async start() {\n    await domReady()\n    this.logDebugActivity(\"application\", \"starting\")\n    this.dispatcher.start()\n    this.router.start()\n    this.logDebugActivity(\"application\", \"start\")\n  }\n\n  stop() {\n    this.logDebugActivity(\"application\", \"stopping\")\n    this.dispatcher.stop()\n    this.router.stop()\n    this.logDebugActivity(\"application\", \"stop\")\n  }\n\n  register(identifier: string, controllerConstructor: ControllerConstructor) {\n    this.load({ identifier, controllerConstructor })\n  }\n\n  load(...definitions: Definition[]): void\n  load(definitions: Definition[]): void\n  load(head: Definition | Definition[], ...rest: Definition[]) {\n    const definitions = Array.isArray(head) ? head : [head, ...rest]\n    definitions.forEach(definition => {\n      if ((definition.controllerConstructor as any).shouldLoad) {\n        this.router.loadDefinition(definition)\n      }\n    })\n  }\n\n  unload(...identifiers: string[]): void\n  unload(identifiers: string[]): void\n  unload(head: string | string[], ...rest: string[]) {\n    const identifiers = Array.isArray(head) ? head : [head, ...rest]\n    identifiers.forEach(identifier => this.router.unloadIdentifier(identifier))\n  }\n\n  // Controllers\n\n  get controllers(): Controller[] {\n    return this.router.contexts.map(context => context.controller)\n  }\n\n  getControllerForElementAndIdentifier(element: Element, identifier: string): Controller | null {\n    const context = this.router.getContextForElementAndIdentifier(element, identifier)\n    return context ? context.controller : null\n  }\n\n  // Error handling\n\n  handleError(error: Error, message: string, detail: object) {\n    this.logger.error(`%s\\n\\n%o\\n\\n%o`, message, error, detail)\n\n    window.onerror?.(message, \"\", 0, 0, error)\n  }\n\n  // Debug logging\n\n  logDebugActivity = (identifier: string, functionName: string, detail: object = {}): void => {\n    if (this.debug) {\n      this.logFormattedMessage(identifier, functionName, detail)\n    }\n  }\n\n  private logFormattedMessage(identifier: string, functionName: string, detail: object = {}) {\n    detail = Object.assign({ application: this }, detail)\n\n    this.logger.groupCollapsed(`${identifier} #${functionName}`)\n    this.logger.log(\"details:\", { ...detail })\n    this.logger.groupEnd()\n  }\n}\n\nfunction domReady() {\n  return new Promise<void>(resolve => {\n    if (document.readyState == \"loading\") {\n      document.addEventListener(\"DOMContentLoaded\", () => resolve())\n    } else {\n      resolve()\n    }\n  })\n}\n","import { Constructor } from \"./constructor\"\nimport { Controller } from \"./controller\"\nimport { readInheritableStaticObjectPairs } from \"./inheritable_statics\"\nimport { camelize, capitalize, dasherize } from \"./string_helpers\"\n\nexport function ValuePropertiesBlessing<T>(constructor: Constructor<T>) {\n  const valueDefinitionPairs = readInheritableStaticObjectPairs<T, ValueTypeDefinition>(constructor, \"values\")\n  const propertyDescriptorMap: PropertyDescriptorMap = {\n    valueDescriptorMap: {\n      get(this: Controller) {\n        return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {\n          const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier)\n          const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key)\n          return Object.assign(result, { [attributeName]: valueDescriptor })\n        }, {} as ValueDescriptorMap)\n      }\n    }\n  }\n\n  return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {\n    return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair))\n  }, propertyDescriptorMap)\n}\n\nexport function propertiesForValueDefinitionPair<T>(valueDefinitionPair: ValueDefinitionPair, controller?: string): PropertyDescriptorMap {\n  const definition = parseValueDefinitionPair(valueDefinitionPair, controller)\n  const { key, name, reader: read, writer: write } = definition\n\n  return {\n    [name]: {\n      get(this: Controller) {\n        const value = this.data.get(key)\n        if (value !== null) {\n          return read(value)\n        } else {\n          return definition.defaultValue\n        }\n      },\n\n      set(this: Controller, value: T | undefined) {\n        if (value === undefined) {\n          this.data.delete(key)\n        } else {\n          this.data.set(key, write(value))\n        }\n      }\n    },\n\n    [`has${capitalize(name)}`]: {\n      get(this: Controller): boolean {\n        return this.data.has(key) || definition.hasCustomDefaultValue\n      }\n    }\n  }\n}\n\nexport type ValueDescriptor = {\n  type: ValueType,\n  key: string,\n  name: string,\n  defaultValue: ValueTypeDefault,\n  hasCustomDefaultValue: boolean,\n  reader: Reader,\n  writer: Writer\n}\n\nexport type ValueDescriptorMap = { [attributeName: string]: ValueDescriptor }\n\nexport type ValueDefinitionMap = { [token: string]: ValueTypeDefinition }\n\nexport type ValueDefinitionPair = [string, ValueTypeDefinition]\n\nexport type ValueTypeConstant = typeof Array | typeof Boolean | typeof Number | typeof Object | typeof String\n\nexport type ValueTypeDefault = Array<any> | Boolean | Number | Object | String\n\nexport type ValueTypeObject = { type: ValueTypeConstant, default: ValueTypeDefault }\n\nexport type ValueTypeDefinition = ValueTypeConstant | ValueTypeDefault | ValueTypeObject\n\nexport type ValueType = \"array\" | \"boolean\" | \"number\" | \"object\" | \"string\"\n\nfunction parseValueDefinitionPair([token, typeDefinition]: ValueDefinitionPair, controller?: string): ValueDescriptor {\n  return valueDescriptorForTokenAndTypeDefinition({\n    controller,\n    token,\n    typeDefinition,\n  })\n}\n\nfunction parseValueTypeConstant(constant: ValueTypeConstant) {\n  switch (constant) {\n    case Array:   return \"array\"\n    case Boolean: return \"boolean\"\n    case Number:  return \"number\"\n    case Object:  return \"object\"\n    case String:  return \"string\"\n  }\n}\n\nfunction parseValueTypeDefault(defaultValue: ValueTypeDefault) {\n  switch (typeof defaultValue) {\n    case \"boolean\": return \"boolean\"\n    case \"number\":  return \"number\"\n    case \"string\":  return \"string\"\n  }\n\n  if (Array.isArray(defaultValue)) return \"array\"\n  if (Object.prototype.toString.call(defaultValue) === \"[object Object]\") return \"object\"\n}\n\nfunction parseValueTypeObject(payload: { controller?: string, token: string, typeObject: ValueTypeObject }) {\n  const typeFromObject = parseValueTypeConstant(payload.typeObject.type)\n\n  if (!typeFromObject) return\n\n  const defaultValueType = parseValueTypeDefault(payload.typeObject.default)\n\n  if (typeFromObject !== defaultValueType) {\n    const propertyPath = payload.controller ? `${payload.controller}.${payload.token}` : payload.token\n\n    throw new Error(`The specified default value for the Stimulus Value \"${propertyPath}\" must match the defined type \"${typeFromObject}\". The provided default value of \"${payload.typeObject.default}\" is of type \"${defaultValueType}\".`)\n  }\n\n  return typeFromObject\n}\n\nfunction parseValueTypeDefinition(payload: { controller?: string, token: string, typeDefinition: ValueTypeDefinition }): ValueType {\n  const typeFromObject = parseValueTypeObject({\n    controller: payload.controller,\n    token: payload.token,\n    typeObject: payload.typeDefinition as ValueTypeObject\n  })\n  const typeFromDefaultValue = parseValueTypeDefault(payload.typeDefinition as ValueTypeDefault)\n  const typeFromConstant = parseValueTypeConstant(payload.typeDefinition as ValueTypeConstant)\n\n  const type = typeFromObject || typeFromDefaultValue || typeFromConstant\n\n  if (type) return type\n\n  const propertyPath = payload.controller ? `${payload.controller}.${payload.typeDefinition}` : payload.token\n\n  throw new Error(`Unknown value type \"${propertyPath}\" for \"${payload.token}\" value`)\n}\n\nfunction defaultValueForDefinition(typeDefinition: ValueTypeDefinition): ValueTypeDefault {\n  const constant = parseValueTypeConstant(typeDefinition as ValueTypeConstant)\n\n  if (constant) return defaultValuesByType[constant]\n\n  const defaultValue = (typeDefinition as ValueTypeObject).default\n  if (defaultValue !== undefined) return defaultValue\n\n  return typeDefinition\n}\n\nfunction valueDescriptorForTokenAndTypeDefinition(payload: { token: string, typeDefinition: ValueTypeDefinition, controller?: string }) {\n  const key = `${dasherize(payload.token)}-value`\n  const type = parseValueTypeDefinition(payload)\n  return {\n    type,\n    key,\n    name: camelize(key),\n    get defaultValue() { return defaultValueForDefinition(payload.typeDefinition) },\n    get hasCustomDefaultValue() { return parseValueTypeDefault(payload.typeDefinition) !== undefined },\n    reader: readers[type],\n    writer: writers[type] || writers.default\n  }\n}\n\nconst defaultValuesByType = {\n  get array() { return [] },\n  boolean: false,\n  number: 0,\n  get object() { return {} },\n  string: \"\"\n}\n\ntype Reader = (value: string) => any\n\nconst readers: { [type: string]: Reader } = {\n  array(value: string): any[] {\n    const array = JSON.parse(value)\n    if (!Array.isArray(array)) {\n      throw new TypeError(`expected value of type \"array\" but instead got value \"${value}\" of type \"${parseValueTypeDefault(array)}\"`)\n    }\n    return array\n  },\n\n  boolean(value: string): boolean {\n    return !(value == \"0\" || String(value).toLowerCase() == \"false\")\n  },\n\n  number(value: string): number {\n    return Number(value)\n  },\n\n  object(value: string): object {\n    const object = JSON.parse(value)\n    if (object === null || typeof object != \"object\" || Array.isArray(object)) {\n      throw new TypeError(`expected value of type \"object\" but instead got value \"${value}\" of type \"${parseValueTypeDefault(object)}\"`)\n    }\n    return object\n  },\n\n  string(value: string): string {\n    return value\n  }\n}\n\ntype Writer = (value: any) => string\n\nconst writers: { [type: string]: Writer } = {\n  default: writeString,\n  array: writeJSON,\n  object: writeJSON\n}\n\nfunction writeJSON(value: any) {\n  return JSON.stringify(value)\n}\n\nfunction writeString(value: any) {\n  return `${value}`\n}\n","import { ClassPropertiesBlessing } from \"./class_properties\"\nimport { Constructor } from \"./constructor\"\nimport { Context } from \"./context\"\nimport { TargetPropertiesBlessing } from \"./target_properties\"\nimport { ValuePropertiesBlessing, ValueDefinitionMap } from \"./value_properties\"\n\nexport type ControllerConstructor = Constructor<Controller>\n\nexport class Controller<ElementType extends Element = Element> {\n  static blessings = [ ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing ]\n  static targets: string[] = []\n  static values: ValueDefinitionMap = {}\n\n  static get shouldLoad() {\n    return true\n  }\n\n  readonly context: Context\n\n  constructor(context: Context) {\n    this.context = context\n  }\n\n  get application() {\n    return this.context.application\n  }\n\n  get scope() {\n    return this.context.scope\n  }\n\n  get element() {\n    return this.scope.element as ElementType\n  }\n\n  get identifier() {\n    return this.scope.identifier\n  }\n\n  get targets() {\n    return this.scope.targets\n  }\n\n  get classes() {\n    return this.scope.classes\n  }\n\n  get data() {\n    return this.scope.data\n  }\n\n  initialize() {\n    // Override in your subclass to set up initial controller state\n  }\n\n  connect() {\n    // Override in your subclass to respond when the controller is connected to the DOM\n  }\n\n  disconnect() {\n    // Override in your subclass to respond when the controller is disconnected from the DOM\n  }\n\n  dispatch(eventName: string, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {\n    const type = prefix ? `${prefix}:${eventName}` : eventName\n    const event = new CustomEvent(type, { detail, bubbles, cancelable })\n    target.dispatchEvent(event)\n    return event\n  }\n}\n","import { Constructor } from \"./constructor\"\nimport { Controller } from \"./controller\"\nimport { readInheritableStaticArrayValues } from \"./inheritable_statics\"\nimport { capitalize } from \"./string_helpers\"\n\nexport function ClassPropertiesBlessing<T>(constructor: Constructor<T>) {\n  const classes = readInheritableStaticArrayValues(constructor, \"classes\")\n  return classes.reduce((properties, classDefinition) => {\n    return Object.assign(properties, propertiesForClassDefinition(classDefinition))\n  }, {} as PropertyDescriptorMap)\n}\n\nfunction propertiesForClassDefinition(key: string) {\n  return {\n    [`${key}Class`]: {\n      get(this: Controller) {\n        const { classes } = this\n        if (classes.has(key)) {\n          return classes.get(key)\n        } else {\n          const attribute = classes.getAttributeName(key)\n          throw new Error(`Missing attribute \"${attribute}\"`)\n        }\n      }\n    },\n\n    [`${key}Classes`]: {\n      get(this: Controller) {\n        return this.classes.getAll(key)\n      }\n    },\n\n    [`has${capitalize(key)}Class`]: {\n      get(this: Controller) {\n        return this.classes.has(key)\n      }\n    }\n  }\n}\n","import { Constructor } from \"./constructor\"\nimport { Controller } from \"./controller\"\nimport { readInheritableStaticArrayValues } from \"./inheritable_statics\"\nimport { capitalize } from \"./string_helpers\"\n\nexport function TargetPropertiesBlessing<T>(constructor: Constructor<T>) {\n  const targets = readInheritableStaticArrayValues(constructor, \"targets\")\n  return targets.reduce((properties, targetDefinition) => {\n    return Object.assign(properties, propertiesForTargetDefinition(targetDefinition))\n  }, {} as PropertyDescriptorMap)\n}\n\nfunction propertiesForTargetDefinition(name: string) {\n  return {\n    [`${name}Target`]: {\n      get(this: Controller) {\n        const target = this.targets.find(name)\n        if (target) {\n          return target\n        } else {\n          throw new Error(`Missing target element \"${name}\" for \"${this.identifier}\" controller`)\n        }\n      }\n    },\n\n    [`${name}Targets`]: {\n      get(this: Controller) {\n        return this.targets.findAll(name)\n      }\n    },\n\n    [`has${capitalize(name)}Target`]: {\n      get(this: Controller) {\n        return this.targets.has(name)\n      }\n    }\n  }\n}\n"],"names":["EventListener","constructor","eventTarget","eventName","eventOptions","this","unorderedBindings","Set","connect","addEventListener","disconnect","removeEventListener","bindingConnected","binding","add","bindingDisconnected","delete","handleEvent","event","extendedEvent","stopImmediatePropagation","Object","assign","immediatePropagationStopped","call","extendEvent","bindings","Array","from","sort","left","right","leftIndex","index","rightIndex","Dispatcher","application","eventListenerMaps","Map","started","start","eventListeners","forEach","eventListener","stop","values","reduce","listeners","map","concat","fetchEventListenerForBinding","handleError","error","message","detail","fetchEventListener","eventListenerMap","fetchEventListenerMapForEventTarget","cacheKey","get","createEventListener","set","parts","keys","key","push","join","descriptorPattern","parseEventTarget","eventTargetName","window","document","camelize","value","replace","_","char","toUpperCase","capitalize","charAt","slice","dasherize","toLowerCase","defaultEventNames","a","e","button","form","details","input","getAttribute","select","textarea","Error","typecast","JSON","parse","o_O","Binding","context","action","identifier","willBeInvokedByEvent","shouldBeInvokedPerSelf","processStopPropagation","processPreventDefault","invokeWithEvent","method","controller","methodName","stopPropagation","prevent","preventDefault","target","currentTarget","params","actionEvent","logDebugActivity","element","self","Element","contains","scope","containsElement","ElementObserver","delegate","attributes","childList","subtree","elements","mutationObserver","MutationObserver","mutations","processMutations","observe","mutationObserverInit","refresh","pause","callback","takeRecords","matches","matchElementsInTree","has","removeElement","addElement","mutation","processMutation","type","processAttributeChange","attributeName","processRemovedNodes","removedNodes","processAddedNodes","addedNodes","node","elementAttributeChanged","matchElement","nodes","elementFromNode","processTree","elementIsActive","tree","processor","nodeType","Node","ELEMENT_NODE","isConnected","elementMatched","elementUnmatched","AttributeObserver","elementObserver","selector","hasAttribute","match","querySelectorAll","elementMatchedAttribute","elementUnmatchedAttribute","elementAttributeValueChanged","StringMapObserver","stringMap","attributeOldValue","knownAttributeNames","refreshAttribute","oldValue","getStringMapKeyForAttribute","stringMapKeyAdded","stringMapValueChanged","stringMapKeyRemoved","currentAttributeNames","recordedAttributeNames","attribute","name","fetch","del","prune","size","Multimap","valuesByKey","hasKey","hasValue","some","getValuesForKey","getKeysForValue","filter","IndexedMultimap","super","keysByValue","TokenListObserver","attributeObserver","tokensByElement","tokensMatched","readTokensForElement","unmatchedTokens","matchedTokens","refreshTokensForElement","tokensUnmatched","tokens","token","tokenMatched","tokenUnmatched","previousTokens","currentTokens","firstDifferingIndex","length","Math","max","zip","findIndex","previousToken","currentToken","content","tokenString","trim","split","parseTokenString","ValueListObserver","tokenListObserver","parseResultsByToken","WeakMap","valuesByTokenByElement","fetchParseResultForToken","fetchValuesByTokenForElement","elementMatchedValue","elementUnmatchedValue","parseResult","parseToken","valuesByToken","parseValueForToken","BindingObserver","bindingsByAction","valueListObserver","actionAttribute","disconnectAllActions","schema","connectAction","disconnectAction","clear","descriptor","tagName","getDefaultEventNameForElement","forToken","descriptorString","options","test","parseActionDescriptorString","toString","eventNameSuffix","pattern","RegExp","ValueObserver","receiver","stringMapObserver","valueDescriptorMap","invokeChangedCallbacksForDefaultValues","invokeChangedCallback","writer","defaultValue","valueDescriptorNameMap","valueDescriptors","undefined","data","rawValue","rawOldValue","changedMethodName","changedMethod","reader","TypeError","descriptors","hasMethodName","TargetObserver","targetsByName","disconnectAllTargets","connectTarget","disconnectTarget","targetConnected","targetDisconnected","Context","module","functionName","controllerConstructor","bindingObserver","dispatcher","valueObserver","targetObserver","initialize","parentElement","invokeControllerMethod","args","readInheritableStaticArrayValues","propertyName","ancestors","getAncestorsForConstructor","definition","isArray","getOwnStaticArrayValues","readInheritableStaticObjectPairs","pairs","getOwnStaticObjectPairs","getPrototypeOf","reverse","bless","properties","shadowConstructor","extend","shadowProperties","prototype","getOwnKeys","shadowingDescriptor","getOwnPropertyDescriptor","getShadowedDescriptor","getShadowProperties","defineProperties","shadow","blessedProperties","blessing","getBlessedProperties","getOwnPropertySymbols","object","getOwnPropertyNames","extendWithReflect","extended","Reflect","construct","arguments","create","setPrototypeOf","b","testReflectExtension","Module","blessDefinition","contextsByScope","connectedContexts","contexts","connectContextForScope","fetchContextForScope","disconnectContextForScope","ClassMap","getDataKey","getAll","getAttributeName","getAttributeNameForKey","DataMap","setAttribute","removeAttribute","Guide","logger","warn","warnedKeys","warnedKeysByObject","attributeValueContainsToken","TargetSet","targetName","find","targetNames","findTarget","findLegacyTarget","findAll","targets","findAllTargets","findAllLegacyTargets","getSelectorForTargetName","findElement","findAllElements","targetAttributeForScope","getLegacySelectorForTargetName","deprecate","targetDescriptor","targetAttribute","revisedAttributeName","guide","Scope","closest","controllerSelector","queryElements","controllerAttribute","ScopeObserver","scopesByIdentifierByElement","scopeReferenceCounts","scopesByIdentifier","fetchScopesByIdentifierForElement","createScopeForElementAndIdentifier","referenceCount","scopeConnected","scopeDisconnected","Router","scopeObserver","modulesByIdentifier","modules","loadDefinition","unloadIdentifier","connectModule","disconnectModule","getContextForElementAndIdentifier","defaultSchema","Application","documentElement","console","debug","logFormattedMessage","router","Promise","resolve","readyState","register","load","head","rest","shouldLoad","unload","controllers","getControllerForElementAndIdentifier","onerror","groupCollapsed","log","groupEnd","parseValueDefinitionPair","typeDefinition","payload","typeFromObject","parseValueTypeConstant","typeObject","defaultValueType","parseValueTypeDefault","default","propertyPath","parseValueTypeObject","typeFromDefaultValue","typeFromConstant","parseValueTypeDefinition","constant","defaultValuesByType","defaultValueForDefinition","hasCustomDefaultValue","readers","writers","valueDescriptorForTokenAndTypeDefinition","Boolean","Number","String","array","boolean","number","string","writeJSON","stringify","Controller","classes","dispatch","prefix","bubbles","cancelable","CustomEvent","dispatchEvent","classDefinition","targetDefinition","valueDefinitionPairs","propertyDescriptorMap","result","valueDefinitionPair","valueDescriptor","read","write","propertiesForValueDefinitionPair"],"mappings":"MAEaA,EAMXC,YAAYC,EAA0BC,EAAmBC,GACvDC,KAAKH,YAAcA,EACnBG,KAAKF,UAAYA,EACjBE,KAAKD,aAAeA,EACpBC,KAAKC,kBAAoB,IAAIC,IAG/BC,UACEH,KAAKH,YAAYO,iBAAiBJ,KAAKF,UAAWE,KAAMA,KAAKD,cAG/DM,aACEL,KAAKH,YAAYS,oBAAoBN,KAAKF,UAAWE,KAAMA,KAAKD,cAKlEQ,iBAAiBC,GACfR,KAAKC,kBAAkBQ,IAAID,GAG7BE,oBAAoBF,GAClBR,KAAKC,kBAAkBU,OAAOH,GAGhCI,YAAYC,GAEV,MAAMC,EAmBV,SAAqBD,GACnB,GAAI,gCAAiCA,EACnC,OAAOA,EACF,CACL,MAAME,yBAAEA,GAA6BF,EACrC,OAAOG,OAAOC,OAAOJ,EAAO,CAC1BK,6BAA6B,EAC7BH,2BACEf,KAAKkB,6BAA8B,EACnCH,EAAyBI,KAAKnB,UA5BZoB,CAAYP,GAClC,IAAK,MAAML,KAAWR,KAAKqB,SAAU,CACnC,GAAIP,EAAcI,4BAChB,MAEAV,EAAQI,YAAYE,IAK1BO,eACE,OAAOC,MAAMC,KAAKvB,KAAKC,mBAAmBuB,MAAK,CAACC,EAAMC,KACpD,MAAMC,EAAYF,EAAKG,MAAOC,EAAaH,EAAME,MACjD,OAAOD,EAAYE,GAAc,EAAIF,EAAYE,EAAa,EAAI,YC3C3DC,EAKXlC,YAAYmC,GACV/B,KAAK+B,YAAcA,EACnB/B,KAAKgC,kBAAoB,IAAIC,IAC7BjC,KAAKkC,SAAU,EAGjBC,QACOnC,KAAKkC,UACRlC,KAAKkC,SAAU,EACflC,KAAKoC,eAAeC,SAAQC,GAAiBA,EAAcnC,aAI/DoC,OACMvC,KAAKkC,UACPlC,KAAKkC,SAAU,EACflC,KAAKoC,eAAeC,SAAQC,GAAiBA,EAAcjC,gBAI/D+B,qBACE,OAAOd,MAAMC,KAAKvB,KAAKgC,kBAAkBQ,UACtCC,QAAO,CAACC,EAAWC,IAAQD,EAAUE,OAAOtB,MAAMC,KAAKoB,EAAIH,YAAY,IAK5EjC,iBAAiBC,GACfR,KAAK6C,6BAA6BrC,GAASD,iBAAiBC,GAG9DE,oBAAoBF,GAClBR,KAAK6C,6BAA6BrC,GAASE,oBAAoBF,GAKjEsC,YAAYC,EAAcC,EAAiBC,EAAiB,IAC1DjD,KAAK+B,YAAYe,YAAYC,EAAO,SAASC,IAAWC,GAGlDJ,6BAA6BrC,GACnC,MAAMX,YAAEA,EAAWC,UAAEA,EAASC,aAAEA,GAAiBS,EACjD,OAAOR,KAAKkD,mBAAmBrD,EAAaC,EAAWC,GAGjDmD,mBAAmBrD,EAA0BC,EAAmBC,GACtE,MAAMoD,EAAmBnD,KAAKoD,oCAAoCvD,GAC5DwD,EAAWrD,KAAKqD,SAASvD,EAAWC,GAC1C,IAAIuC,EAAgBa,EAAiBG,IAAID,GAKzC,OAJKf,IACHA,EAAgBtC,KAAKuD,oBAAoB1D,EAAaC,EAAWC,GACjEoD,EAAiBK,IAAIH,EAAUf,IAE1BA,EAGDiB,oBAAoB1D,EAA0BC,EAAmBC,GACvE,MAAMuC,EAAgB,IAAI3C,EAAcE,EAAaC,EAAWC,GAIhE,OAHIC,KAAKkC,SACPI,EAAcnC,UAETmC,EAGDc,oCAAoCvD,GAC1C,IAAIsD,EAAmBnD,KAAKgC,kBAAkBsB,IAAIzD,GAKlD,OAJKsD,IACHA,EAAmB,IAAIlB,IACvBjC,KAAKgC,kBAAkBwB,IAAI3D,EAAasD,IAEnCA,EAGDE,SAASvD,EAAmBC,GAClC,MAAM0D,EAAQ,CAAE3D,GAIhB,OAHAkB,OAAO0C,KAAK3D,GAAcyB,OAAOa,SAAQsB,IACvCF,EAAMG,KAAK,GAAG7D,EAAa4D,GAAO,GAAK,MAAMA,QAExCF,EAAMI,KAAK,MC9EtB,MAAMC,EAAoB,4DAc1B,SAASC,EAAiBC,GACxB,MAAuB,UAAnBA,EACKC,OACqB,YAAnBD,EACFE,cADF,WC5BOC,EAASC,GACvB,OAAOA,EAAMC,QAAQ,uBAAuB,CAACC,EAAGC,IAASA,EAAKC,yBAGhDC,EAAWL,GACzB,OAAOA,EAAMM,OAAO,GAAGF,cAAgBJ,EAAMO,MAAM,YAGrCC,EAAUR,GACxB,OAAOA,EAAMC,QAAQ,YAAY,CAACC,EAAGC,IAAS,IAAIA,EAAKM,kBC2CzD,MAAMC,EAAyE,CAC7EC,EAAYC,GAAK,QACjBC,OAAYD,GAAK,QACjBE,KAAYF,GAAK,SACjBG,QAAYH,GAAK,SACjBI,MAAYJ,GAA+B,UAA1BA,EAAEK,aAAa,QAAsB,QAAU,QAChEC,OAAYN,GAAK,SACjBO,SAAYP,GAAK,SAUnB,SAASjC,EAAMC,GACb,MAAM,IAAIwC,MAAMxC,GAGlB,SAASyC,EAASrB,GAChB,IACE,OAAOsB,KAAKC,MAAMvB,GAClB,MAAOwB,GACP,OAAOxB,SCtEEyB,EAIXjG,YAAYkG,EAAkBC,GAC5B/F,KAAK8F,QAAUA,EACf9F,KAAK+F,OAASA,EAGhBnE,YACE,OAAO5B,KAAK+F,OAAOnE,MAGrB/B,kBACE,OAAOG,KAAK+F,OAAOlG,YAGrBE,mBACE,OAAOC,KAAK+F,OAAOhG,aAGrBiG,iBACE,OAAOhG,KAAK8F,QAAQE,WAGtBpF,YAAYC,GACNb,KAAKiG,qBAAqBpF,IAAUb,KAAKkG,uBAAuBrF,KAClEb,KAAKmG,uBAAuBtF,GAC5Bb,KAAKoG,sBAAsBvF,GAE3Bb,KAAKqG,gBAAgBxF,IAIzBf,gBACE,OAAOE,KAAK+F,OAAOjG,UAGrBwG,aACE,MAAMA,EAAUtG,KAAKuG,WAAmBvG,KAAKwG,YAC7C,GAAqB,mBAAVF,EACT,OAAOA,EAET,MAAM,IAAId,MAAM,WAAWxF,KAAK+F,wCAAwC/F,KAAKwG,eAGvEL,uBAAuBtF,GACzBb,KAAKD,aAAawC,MACpB1B,EAAM4F,kBAIFL,sBAAsBvF,GACxBb,KAAKD,aAAa2G,SACpB7F,EAAM8F,iBAIFN,gBAAgBxF,GACtB,MAAM+F,OAAEA,EAAMC,cAAEA,GAAkBhG,EAClC,IACE,MAAMiG,OAAEA,GAAW9G,KAAK+F,OAClBgB,EAA2B/F,OAAOC,OAAOJ,EAAO,CAAEiG,OAAAA,IACxD9G,KAAKsG,OAAOnF,KAAKnB,KAAKuG,WAAYQ,GAClC/G,KAAK8F,QAAQkB,iBAAiBhH,KAAKwG,WAAY,CAAE3F,MAAAA,EAAO+F,OAAAA,EAAQC,cAAAA,EAAed,OAAQ/F,KAAKwG,aAC5F,MAAOzD,GACP,MAAMiD,WAAEA,EAAUO,WAAEA,EAAUU,QAAEA,EAAOrF,MAAEA,GAAU5B,KAC7CiD,EAAS,CAAE+C,WAAAA,EAAYO,WAAAA,EAAYU,QAAAA,EAASrF,MAAAA,EAAOf,MAAAA,GACzDb,KAAK8F,QAAQhD,YAAYC,EAAO,oBAAoB/C,KAAK+F,UAAW9C,IAIhEiD,uBAAuBrF,GAC7B,OAAsC,IAAlCb,KAAK+F,OAAOhG,aAAamH,MACpBlH,KAAK+F,OAAOkB,UAAYpG,EAAM+F,OAMjCX,qBAAqBpF,GAC3B,MAAMhB,EAAcgB,EAAM+F,OAC1B,OAAI5G,KAAKiH,UAAYpH,IAEVA,aAAuBsH,SAAWnH,KAAKiH,QAAQG,SAASvH,GAC1DG,KAAKqH,MAAMC,gBAAgBzH,GAE3BG,KAAKqH,MAAMC,gBAAgBtH,KAAK+F,OAAOkB,UAIlDV,iBACE,OAAOvG,KAAK8F,QAAQS,WAGtBC,iBACE,OAAOxG,KAAK+F,OAAOS,WAGrBS,cACE,OAAOjH,KAAKqH,MAAMJ,QAGpBI,YACE,OAAOrH,KAAK8F,QAAQuB,aCtGXE,EASX3H,YAAYqH,EAAkBO,GAFtBxH,0BAAuB,CAAEyH,YAAY,EAAMC,WAAW,EAAMC,SAAS,GAG3E3H,KAAKiH,QAAUA,EACfjH,KAAKkC,SAAU,EACflC,KAAKwH,SAAWA,EAEhBxH,KAAK4H,SAAW,IAAI1H,IACpBF,KAAK6H,iBAAmB,IAAIC,kBAAkBC,GAAc/H,KAAKgI,iBAAiBD,KAGpF5F,QACOnC,KAAKkC,UACRlC,KAAKkC,SAAU,EACflC,KAAK6H,iBAAiBI,QAAQjI,KAAKiH,QAASjH,KAAKkI,sBACjDlI,KAAKmI,WAITC,MAAMC,GACArI,KAAKkC,UACPlC,KAAK6H,iBAAiBxH,aACtBL,KAAKkC,SAAU,GAGjBmG,IAEKrI,KAAKkC,UACRlC,KAAK6H,iBAAiBI,QAAQjI,KAAKiH,QAASjH,KAAKkI,sBACjDlI,KAAKkC,SAAU,GAInBK,OACMvC,KAAKkC,UACPlC,KAAK6H,iBAAiBS,cACtBtI,KAAK6H,iBAAiBxH,aACtBL,KAAKkC,SAAU,GAInBiG,UACE,GAAInI,KAAKkC,QAAS,CAChB,MAAMqG,EAAU,IAAIrI,IAAIF,KAAKwI,uBAE7B,IAAK,MAAMvB,KAAW3F,MAAMC,KAAKvB,KAAK4H,UAC/BW,EAAQE,IAAIxB,IACfjH,KAAK0I,cAAczB,GAIvB,IAAK,MAAMA,KAAW3F,MAAMC,KAAKgH,GAC/BvI,KAAK2I,WAAW1B,IAOde,iBAAiBD,GACvB,GAAI/H,KAAKkC,QACP,IAAK,MAAM0G,KAAYb,EACrB/H,KAAK6I,gBAAgBD,GAKnBC,gBAAgBD,GACD,cAAjBA,EAASE,KACX9I,KAAK+I,uBAAuBH,EAAShC,OAAQgC,EAASI,eAC5B,aAAjBJ,EAASE,OAClB9I,KAAKiJ,oBAAoBL,EAASM,cAClClJ,KAAKmJ,kBAAkBP,EAASQ,aAI5BL,uBAAuBM,EAAYL,GACzC,MAAM/B,EAAUoC,EACZrJ,KAAK4H,SAASa,IAAIxB,GAChBjH,KAAKwH,SAAS8B,yBAA2BtJ,KAAKuJ,aAAatC,GAC7DjH,KAAKwH,SAAS8B,wBAAwBrC,EAAS+B,GAE/ChJ,KAAK0I,cAAczB,GAEZjH,KAAKuJ,aAAatC,IAC3BjH,KAAK2I,WAAW1B,GAIZgC,oBAAoBO,GAC1B,IAAK,MAAMH,KAAQ/H,MAAMC,KAAKiI,GAAQ,CACpC,MAAMvC,EAAUjH,KAAKyJ,gBAAgBJ,GACjCpC,GACFjH,KAAK0J,YAAYzC,EAASjH,KAAK0I,gBAK7BS,kBAAkBK,GACxB,IAAK,MAAMH,KAAQ/H,MAAMC,KAAKiI,GAAQ,CACpC,MAAMvC,EAAUjH,KAAKyJ,gBAAgBJ,GACjCpC,GAAWjH,KAAK2J,gBAAgB1C,IAClCjH,KAAK0J,YAAYzC,EAASjH,KAAK2I,aAO7BY,aAAatC,GACnB,OAAOjH,KAAKwH,SAAS+B,aAAatC,GAG5BuB,oBAAoBoB,EAAgB5J,KAAKiH,SAC/C,OAAOjH,KAAKwH,SAASgB,oBAAoBoB,GAGnCF,YAAYE,EAAeC,GACjC,IAAK,MAAM5C,KAAWjH,KAAKwI,oBAAoBoB,GAC7CC,EAAU1I,KAAKnB,KAAMiH,GAIjBwC,gBAAgBJ,GACtB,GAAIA,EAAKS,UAAYC,KAAKC,aACxB,OAAOX,EAIHM,gBAAgB1C,GACtB,OAAIA,EAAQgD,aAAejK,KAAKiH,QAAQgD,aAG/BjK,KAAKiH,QAAQG,SAASH,GAMzB0B,WAAW1B,GACZjH,KAAK4H,SAASa,IAAIxB,IACjBjH,KAAK2J,gBAAgB1C,KACvBjH,KAAK4H,SAASnH,IAAIwG,GACdjH,KAAKwH,SAAS0C,gBAChBlK,KAAKwH,SAAS0C,eAAejD,IAM7ByB,cAAczB,GAChBjH,KAAK4H,SAASa,IAAIxB,KACpBjH,KAAK4H,SAASjH,OAAOsG,GACjBjH,KAAKwH,SAAS2C,kBAChBnK,KAAKwH,SAAS2C,iBAAiBlD,WClK1BmD,EAMXxK,YAAYqH,EAAkB+B,EAAuBxB,GACnDxH,KAAKgJ,cAAgBA,EACrBhJ,KAAKwH,SAAWA,EAEhBxH,KAAKqK,gBAAkB,IAAI9C,EAAgBN,EAASjH,MAGtDiH,cACE,OAAOjH,KAAKqK,gBAAgBpD,QAG9BqD,eACE,MAAO,IAAItK,KAAKgJ,iBAGlB7G,QACEnC,KAAKqK,gBAAgBlI,QAGvBiG,MAAMC,GACJrI,KAAKqK,gBAAgBjC,MAAMC,GAG7B9F,OACEvC,KAAKqK,gBAAgB9H,OAGvB4F,UACEnI,KAAKqK,gBAAgBlC,UAGvBjG,cACE,OAAOlC,KAAKqK,gBAAgBnI,QAK9BqH,aAAatC,GACX,OAAOA,EAAQsD,aAAavK,KAAKgJ,eAGnCR,oBAAoBoB,GAClB,MAAMY,EAAQxK,KAAKuJ,aAAaK,GAAQ,CAACA,GAAQ,GAC3CrB,EAAUjH,MAAMC,KAAKqI,EAAKa,iBAAiBzK,KAAKsK,WACtD,OAAOE,EAAM5H,OAAO2F,GAGtB2B,eAAejD,GACTjH,KAAKwH,SAASkD,yBAChB1K,KAAKwH,SAASkD,wBAAwBzD,EAASjH,KAAKgJ,eAIxDmB,iBAAiBlD,GACXjH,KAAKwH,SAASmD,2BAChB3K,KAAKwH,SAASmD,0BAA0B1D,EAASjH,KAAKgJ,eAI1DM,wBAAwBrC,EAAkB+B,GACpChJ,KAAKwH,SAASoD,8BAAgC5K,KAAKgJ,eAAiBA,GACtEhJ,KAAKwH,SAASoD,6BAA6B3D,EAAS+B,UCpE7C6B,EAOXjL,YAAYqH,EAAkBO,GAC5BxH,KAAKiH,QAAUA,EACfjH,KAAKwH,SAAWA,EAChBxH,KAAKkC,SAAU,EACflC,KAAK8K,UAAY,IAAI7I,IACrBjC,KAAK6H,iBAAmB,IAAIC,kBAAiBC,GAAa/H,KAAKgI,iBAAiBD,KAGlF5F,QACOnC,KAAKkC,UACRlC,KAAKkC,SAAU,EACflC,KAAK6H,iBAAiBI,QAAQjI,KAAKiH,QAAS,CAAEQ,YAAY,EAAMsD,mBAAmB,IACnF/K,KAAKmI,WAIT5F,OACMvC,KAAKkC,UACPlC,KAAK6H,iBAAiBS,cACtBtI,KAAK6H,iBAAiBxH,aACtBL,KAAKkC,SAAU,GAInBiG,UACE,GAAInI,KAAKkC,QACP,IAAK,MAAM8G,KAAiBhJ,KAAKgL,oBAC/BhL,KAAKiL,iBAAiBjC,EAAe,MAOnChB,iBAAiBD,GACvB,GAAI/H,KAAKkC,QACP,IAAK,MAAM0G,KAAYb,EACrB/H,KAAK6I,gBAAgBD,GAKnBC,gBAAgBD,GACtB,MAAMI,EAAgBJ,EAASI,cAC3BA,GACFhJ,KAAKiL,iBAAiBjC,EAAeJ,EAASsC,UAM1CD,iBAAiBjC,EAAuBkC,GAC9C,MAAMvH,EAAM3D,KAAKwH,SAAS2D,4BAA4BnC,GACtD,GAAW,MAAPrF,EAAa,CACV3D,KAAK8K,UAAUrC,IAAIO,IACtBhJ,KAAKoL,kBAAkBzH,EAAKqF,GAG9B,MAAM5E,EAAQpE,KAAKiH,QAAQ5B,aAAa2D,GAKxC,GAJIhJ,KAAK8K,UAAUxH,IAAI0F,IAAkB5E,GACvCpE,KAAKqL,sBAAsBjH,EAAOT,EAAKuH,GAG5B,MAAT9G,EAAe,CACjB,MAAM8G,EAAWlL,KAAK8K,UAAUxH,IAAI0F,GACpChJ,KAAK8K,UAAUnK,OAAOqI,GAClBkC,GAAUlL,KAAKsL,oBAAoB3H,EAAKqF,EAAekC,QAE3DlL,KAAK8K,UAAUtH,IAAIwF,EAAe5E,IAKhCgH,kBAAkBzH,EAAaqF,GACjChJ,KAAKwH,SAAS4D,mBAChBpL,KAAKwH,SAAS4D,kBAAkBzH,EAAKqF,GAIjCqC,sBAAsBjH,EAAsBT,EAAauH,GAC3DlL,KAAKwH,SAAS6D,uBAChBrL,KAAKwH,SAAS6D,sBAAsBjH,EAAOT,EAAKuH,GAI5CI,oBAAoB3H,EAAaqF,EAAuBkC,GAC1DlL,KAAKwH,SAAS8D,qBAChBtL,KAAKwH,SAAS8D,oBAAoB3H,EAAKqF,EAAekC,GAI1DF,0BACE,OAAO1J,MAAMC,KAAK,IAAIrB,IAAIF,KAAKuL,sBAAsB3I,OAAO5C,KAAKwL,0BAGnED,4BACE,OAAOjK,MAAMC,KAAKvB,KAAKiH,QAAQQ,YAAY9E,KAAI8I,GAAaA,EAAUC,OAGxEF,6BACE,OAAOlK,MAAMC,KAAKvB,KAAK8K,UAAUpH,kBClHrBjD,EAAUkC,EAAqBgB,EAAQS,GACrDuH,EAAMhJ,EAAKgB,GAAKlD,IAAI2D,YAGNwH,EAAUjJ,EAAqBgB,EAAQS,GACrDuH,EAAMhJ,EAAKgB,GAAKhD,OAAOyD,GACvByH,EAAMlJ,EAAKgB,YAGGgI,EAAYhJ,EAAqBgB,GAC/C,IAAInB,EAASG,EAAIW,IAAIK,GAKrB,OAJKnB,IACHA,EAAS,IAAItC,IACbyC,EAAIa,IAAIG,EAAKnB,IAERA,WAGOqJ,EAAYlJ,EAAqBgB,GAC/C,MAAMnB,EAASG,EAAIW,IAAIK,GACT,MAAVnB,GAAiC,GAAfA,EAAOsJ,MAC3BnJ,EAAIhC,OAAOgD,SCnBFoI,EAGXnM,cACEI,KAAKgM,YAAc,IAAI/J,IAGzByB,WACE,OAAOpC,MAAMC,KAAKvB,KAAKgM,YAAYtI,QAGrClB,aAEE,OADalB,MAAMC,KAAKvB,KAAKgM,YAAYxJ,UAC7BC,QAAO,CAACD,EAAQgB,IAAQhB,EAAOI,OAAOtB,MAAMC,KAAKiC,KAAa,IAG5EsI,WAEE,OADaxK,MAAMC,KAAKvB,KAAKgM,YAAYxJ,UAC7BC,QAAO,CAACqJ,EAAMtI,IAAQsI,EAAOtI,EAAIsI,MAAM,GAGrDrL,IAAIkD,EAAQS,GACV3D,EAAIT,KAAKgM,YAAarI,EAAKS,GAG7BzD,OAAOgD,EAAQS,GACbwH,EAAI5L,KAAKgM,YAAarI,EAAKS,GAG7BqE,IAAI9E,EAAQS,GACV,MAAM5B,EAASxC,KAAKgM,YAAY1I,IAAIK,GACpC,OAAiB,MAAVnB,GAAkBA,EAAOiG,IAAIrE,GAGtC6H,OAAOtI,GACL,OAAO3D,KAAKgM,YAAYvD,IAAI9E,GAG9BuI,SAAS9H,GAEP,OADa9C,MAAMC,KAAKvB,KAAKgM,YAAYxJ,UAC7B2J,MAAK3I,GAAOA,EAAIiF,IAAIrE,KAGlCgI,gBAAgBzI,GACd,MAAMnB,EAASxC,KAAKgM,YAAY1I,IAAIK,GACpC,OAAOnB,EAASlB,MAAMC,KAAKiB,GAAU,GAGvC6J,gBAAgBjI,GACd,OAAO9C,MAAMC,KAAKvB,KAAKgM,aACpBM,QAAO,EAAE3I,EAAKnB,KAAYA,EAAOiG,IAAIrE,KACrCzB,KAAI,EAAEgB,EAAKnB,KAAYmB,WClDjB4I,UAA8BR,EAGzCnM,cACE4M,QACAxM,KAAKyM,YAAc,IAAIxK,IAGzBO,aACE,OAAOlB,MAAMC,KAAKvB,KAAKyM,YAAY/I,QAGrCjD,IAAIkD,EAAQS,GACVoI,MAAM/L,IAAIkD,EAAKS,GACf3D,EAAIT,KAAKyM,YAAarI,EAAOT,GAG/BhD,OAAOgD,EAAQS,GACboI,MAAM7L,OAAOgD,EAAKS,GAClBwH,EAAI5L,KAAKyM,YAAarI,EAAOT,GAG/BuI,SAAS9H,GACP,OAAOpE,KAAKyM,YAAYhE,IAAIrE,GAG9BiI,gBAAgBjI,GACd,MAAMZ,EAAMxD,KAAKyM,YAAYnJ,IAAIc,GACjC,OAAOZ,EAAMlC,MAAMC,KAAKiC,GAAO,UChBtBkJ,EAKX9M,YAAYqH,EAAkB+B,EAAuBxB,GACnDxH,KAAK2M,kBAAoB,IAAIvC,EAAkBnD,EAAS+B,EAAehJ,MACvEA,KAAKwH,SAAWA,EAChBxH,KAAK4M,gBAAkB,IAAIb,EAG7B7J,cACE,OAAOlC,KAAK2M,kBAAkBzK,QAGhCC,QACEnC,KAAK2M,kBAAkBxK,QAGzBiG,MAAMC,GACJrI,KAAK2M,kBAAkBvE,MAAMC,GAG/B9F,OACEvC,KAAK2M,kBAAkBpK,OAGzB4F,UACEnI,KAAK2M,kBAAkBxE,UAGzBlB,cACE,OAAOjH,KAAK2M,kBAAkB1F,QAGhC+B,oBACE,OAAOhJ,KAAK2M,kBAAkB3D,cAKhC0B,wBAAwBzD,GACtBjH,KAAK6M,cAAc7M,KAAK8M,qBAAqB7F,IAG/C2D,6BAA6B3D,GAC3B,MAAO8F,EAAiBC,GAAiBhN,KAAKiN,wBAAwBhG,GACtEjH,KAAKkN,gBAAgBH,GACrB/M,KAAK6M,cAAcG,GAGrBrC,0BAA0B1D,GACxBjH,KAAKkN,gBAAgBlN,KAAK4M,gBAAgBR,gBAAgBnF,IAGpD4F,cAAcM,GACpBA,EAAO9K,SAAQ+K,GAASpN,KAAKqN,aAAaD,KAGpCF,gBAAgBC,GACtBA,EAAO9K,SAAQ+K,GAASpN,KAAKsN,eAAeF,KAGtCC,aAAaD,GACnBpN,KAAKwH,SAAS6F,aAAaD,GAC3BpN,KAAK4M,gBAAgBnM,IAAI2M,EAAMnG,QAASmG,GAGlCE,eAAeF,GACrBpN,KAAKwH,SAAS8F,eAAeF,GAC7BpN,KAAK4M,gBAAgBjM,OAAOyM,EAAMnG,QAASmG,GAGrCH,wBAAwBhG,GAC9B,MAAMsG,EAAiBvN,KAAK4M,gBAAgBR,gBAAgBnF,GACtDuG,EAAgBxN,KAAK8M,qBAAqB7F,GAC1CwG,EAsBV,SAAmBhM,EAAWC,GAC5B,MAAMgM,EAASC,KAAKC,IAAInM,EAAKiM,OAAQhM,EAAMgM,QAC3C,OAAOpM,MAAMC,KAAK,CAAEmM,OAAAA,IAAU,CAACpJ,EAAG1C,IAAU,CAACH,EAAKG,GAAQF,EAAME,MAxBlCiM,CAAIN,EAAgBC,GAC7CM,WAAU,EAAEC,EAAeC,MAAkB,OA0BdtM,EA1B6CsM,KA0B3DvM,EA1B4CsM,IA2BnDrM,GAASD,EAAKG,OAASF,EAAME,OAASH,EAAKwM,SAAWvM,EAAMuM,SAD7E,IAAwBxM,EAAcC,KAxBlC,OAA4B,GAAxB+L,EACK,CAAC,GAAI,IAEL,CAACF,EAAe5I,MAAM8I,GAAsBD,EAAc7I,MAAM8I,IAInEX,qBAAqB7F,GAC3B,MAAM+B,EAAgBhJ,KAAKgJ,cAE3B,OAIJ,SAA0BkF,EAAqBjH,EAAkB+B,GAC/D,OAAOkF,EAAYC,OAAOC,MAAM,OAAO9B,QAAO2B,GAAWA,EAAQP,SAC9D/K,KAAI,CAACsL,EAASrM,MAAaqF,QAAAA,EAAS+B,cAAAA,EAAeiF,QAAAA,EAASrM,MAAAA,MANtDyM,CADapH,EAAQ5B,aAAa2D,IAAkB,GACtB/B,EAAS+B,UC3FrCsF,EAMX1O,YAAYqH,EAAkB+B,EAAuBxB,GACnDxH,KAAKuO,kBAAoB,IAAI7B,EAAkBzF,EAAS+B,EAAehJ,MACvEA,KAAKwH,SAAWA,EAChBxH,KAAKwO,oBAAsB,IAAIC,QAC/BzO,KAAK0O,uBAAyB,IAAID,QAGpCvM,cACE,OAAOlC,KAAKuO,kBAAkBrM,QAGhCC,QACEnC,KAAKuO,kBAAkBpM,QAGzBI,OACEvC,KAAKuO,kBAAkBhM,OAGzB4F,UACEnI,KAAKuO,kBAAkBpG,UAGzBlB,cACE,OAAOjH,KAAKuO,kBAAkBtH,QAGhC+B,oBACE,OAAOhJ,KAAKuO,kBAAkBvF,cAGhCqE,aAAaD,GACX,MAAMnG,QAAEA,GAAYmG,GACdhJ,MAAEA,GAAUpE,KAAK2O,yBAAyBvB,GAC5ChJ,IACFpE,KAAK4O,6BAA6B3H,GAASzD,IAAI4J,EAAOhJ,GACtDpE,KAAKwH,SAASqH,oBAAoB5H,EAAS7C,IAI/CkJ,eAAeF,GACb,MAAMnG,QAAEA,GAAYmG,GACdhJ,MAAEA,GAAUpE,KAAK2O,yBAAyBvB,GAC5ChJ,IACFpE,KAAK4O,6BAA6B3H,GAAStG,OAAOyM,GAClDpN,KAAKwH,SAASsH,sBAAsB7H,EAAS7C,IAIzCuK,yBAAyBvB,GAC/B,IAAI2B,EAAc/O,KAAKwO,oBAAoBlL,IAAI8J,GAK/C,OAJK2B,IACHA,EAAc/O,KAAKgP,WAAW5B,GAC9BpN,KAAKwO,oBAAoBhL,IAAI4J,EAAO2B,IAE/BA,EAGDH,6BAA6B3H,GACnC,IAAIgI,EAAgBjP,KAAK0O,uBAAuBpL,IAAI2D,GAKpD,OAJKgI,IACHA,EAAgB,IAAIhN,IACpBjC,KAAK0O,uBAAuBlL,IAAIyD,EAASgI,IAEpCA,EAGDD,WAAW5B,GACjB,IAEE,MAAO,CAAEhJ,MADKpE,KAAKwH,SAAS0H,mBAAmB9B,IAE/C,MAAOrK,GACP,MAAO,CAAEA,MAAAA,WC/EFoM,EAMXvP,YAAYkG,EAAkB0B,GAC5BxH,KAAK8F,QAAUA,EACf9F,KAAKwH,SAAWA,EAChBxH,KAAKoP,iBAAmB,IAAInN,IAG9BE,QACOnC,KAAKqP,oBACRrP,KAAKqP,kBAAoB,IAAIf,EAAkBtO,KAAKiH,QAASjH,KAAKsP,gBAAiBtP,MACnFA,KAAKqP,kBAAkBlN,SAI3BI,OACMvC,KAAKqP,oBACPrP,KAAKqP,kBAAkB9M,cAChBvC,KAAKqP,kBACZrP,KAAKuP,wBAITtI,cACE,OAAOjH,KAAK8F,QAAQmB,QAGtBjB,iBACE,OAAOhG,KAAK8F,QAAQE,WAGtBsJ,sBACE,OAAOtP,KAAKwP,OAAOF,gBAGrBE,aACE,OAAOxP,KAAK8F,QAAQ0J,OAGtBnO,eACE,OAAOC,MAAMC,KAAKvB,KAAKoP,iBAAiB5M,UAGlCiN,cAAc1J,GACpB,MAAMvF,EAAU,IAAIqF,EAAQ7F,KAAK8F,QAASC,GAC1C/F,KAAKoP,iBAAiB5L,IAAIuC,EAAQvF,GAClCR,KAAKwH,SAASjH,iBAAiBC,GAGzBkP,iBAAiB3J,GACvB,MAAMvF,EAAUR,KAAKoP,iBAAiB9L,IAAIyC,GACtCvF,IACFR,KAAKoP,iBAAiBzO,OAAOoF,GAC7B/F,KAAKwH,SAAS9G,oBAAoBF,IAI9B+O,uBACNvP,KAAKqB,SAASgB,SAAQ7B,GAAWR,KAAKwH,SAAS9G,oBAAoBF,KACnER,KAAKoP,iBAAiBO,QAKxBT,mBAAmB9B,GACjB,MAAMrH,QV/DRnG,YAAYqH,EAAkBrF,EAAegO,GAC3C5P,KAAKiH,QAAeA,EACpBjH,KAAK4B,MAAeA,EACpB5B,KAAKH,YAAe+P,EAAW/P,aAAeoH,EAC9CjH,KAAKF,UAAe8P,EAAW9P,oBAwCWmH,GAC5C,MAAM4I,EAAU5I,EAAQ4I,QAAQhL,cAChC,GAAIgL,KAAW/K,EACb,OAAOA,EAAkB+K,GAAS5I,GA3CU6I,CAA8B7I,IAAYlE,EAAM,sBAC5F/C,KAAKD,aAAe6P,EAAW7P,cAAgB,GAC/CC,KAAKgG,WAAe4J,EAAW5J,YAAcjD,EAAM,sBACnD/C,KAAKwG,WAAeoJ,EAAWpJ,YAAczD,EAAM,uBAXrDgN,gBAAgB3C,GACd,OAAO,IAAIpN,KAAKoN,EAAMnG,QAASmG,EAAMxL,eFFGoO,GAC1C,MACMzH,EADSyH,EAAiB7B,OACT3D,MAAM1G,IAAsB,GACnD,MAAO,CACLjE,YAAckE,EAAiBwE,EAAQ,IACvCzI,UAAcyI,EAAQ,GACtBxI,aAAcwI,EAAQ,IAcCxI,EAdsBwI,EAAQ,GAehDxI,EAAaqO,MAAM,KAAK3L,QAAO,CAACwN,EAAS7C,IAC9CpM,OAAOC,OAAOgP,EAAS,CAAE,CAAC7C,EAAM/I,QAAQ,KAAM,MAAO,KAAK6L,KAAK9C,MAC/D,KAjB2D,GAC3DpH,WAAcuC,EAAQ,GACtB/B,WAAc+B,EAAQ,IAY1B,IAA2BxI,EElBqBoQ,CAA4B/C,EAAMa,UAahFmC,WACE,MAAMC,EAAkBrQ,KAAKgE,gBAAkB,IAAIhE,KAAKgE,kBAAoB,GAC5E,MAAO,GAAGhE,KAAKF,YAAYuQ,MAAoBrQ,KAAKgG,cAAchG,KAAKwG,aAGzEM,aACE,MAAMA,EAAgC,GAChCwJ,EAAU,IAAIC,OAAO,SAASvQ,KAAKgG,0BAEzC,IAAK,MAAM0F,KAAEA,EAAItH,MAAEA,KAAW9C,MAAMC,KAAKvB,KAAKiH,QAAQQ,YAAa,CACjE,MAAM+C,EAAQkB,EAAKlB,MAAM8F,GACnB3M,EAAM6G,GAASA,EAAM,GACvB7G,IACFmD,EAAO3C,EAASR,IAAO8B,EAASrB,IAGpC,OAAO0C,EAGT9C,sBACE,OFTiCnE,EESLG,KAAKH,cFRhBoE,OACV,SACEpE,GAAeqE,SACjB,gBADF,MAH4BrE,IY0CXkQ,SAAS3C,GAC/B,GAAIrH,EAAOC,YAAchG,KAAKgG,WAC5B,OAAOD,EAIX8I,oBAAoB5H,EAAkBlB,GACpC/F,KAAKyP,cAAc1J,GAGrB+I,sBAAsB7H,EAAkBlB,GACtC/F,KAAK0P,iBAAiB3J,UCvFbyK,EAMX5Q,YAAYkG,EAAkB2K,GAC5BzQ,KAAK8F,QAAUA,EACf9F,KAAKyQ,SAAWA,EAChBzQ,KAAK0Q,kBAAoB,IAAI7F,EAAkB7K,KAAKiH,QAASjH,MAC7DA,KAAK2Q,mBAAsB3Q,KAAKuG,WAAmBoK,mBAGrDxO,QACEnC,KAAK0Q,kBAAkBvO,QACvBnC,KAAK4Q,yCAGPrO,OACEvC,KAAK0Q,kBAAkBnO,OAGzB0E,cACE,OAAOjH,KAAK8F,QAAQmB,QAGtBV,iBACE,OAAOvG,KAAK8F,QAAQS,WAKtB4E,4BAA4BnC,GAC1B,GAAIA,KAAiBhJ,KAAK2Q,mBACxB,OAAO3Q,KAAK2Q,mBAAmB3H,GAAe0C,KAIlDN,kBAAkBzH,EAAaqF,GAC7B,MAAM4G,EAAa5P,KAAK2Q,mBAAmB3H,GAEtChJ,KAAKkM,SAASvI,IACjB3D,KAAK6Q,sBAAsBlN,EAAKiM,EAAWkB,OAAO9Q,KAAKyQ,SAAS9M,IAAOiM,EAAWkB,OAAOlB,EAAWmB,eAIxG1F,sBAAsBjH,EAAesH,EAAcR,GACjD,MAAM0E,EAAa5P,KAAKgR,uBAAuBtF,GAEjC,OAAVtH,IAEa,OAAb8G,IACFA,EAAW0E,EAAWkB,OAAOlB,EAAWmB,eAG1C/Q,KAAK6Q,sBAAsBnF,EAAMtH,EAAO8G,IAG1CI,oBAAoB3H,EAAaqF,EAAuBkC,GACtD,MAAM0E,EAAa5P,KAAKgR,uBAAuBrN,GAE3C3D,KAAKkM,SAASvI,GAChB3D,KAAK6Q,sBAAsBlN,EAAKiM,EAAWkB,OAAO9Q,KAAKyQ,SAAS9M,IAAOuH,GAEvElL,KAAK6Q,sBAAsBlN,EAAKiM,EAAWkB,OAAOlB,EAAWmB,cAAe7F,GAIxE0F,yCACN,IAAK,MAAMjN,IAAEA,EAAG+H,KAAEA,EAAIqF,aAAEA,EAAYD,OAAEA,KAAY9Q,KAAKiR,iBACjCC,MAAhBH,GAA8B/Q,KAAKuG,WAAW4K,KAAK1I,IAAI9E,IACzD3D,KAAK6Q,sBAAsBnF,EAAMoF,EAAOC,QAAeG,GAKrDL,sBAAsBnF,EAAc0F,EAAkBC,GAC5D,MAAMC,EAAoB,GAAG5F,WACvB6F,EAAgBvR,KAAKyQ,SAASa,GAEpC,GAA4B,mBAAjBC,EAA6B,CACtC,MAAM3B,EAAa5P,KAAKgR,uBAAuBtF,GAE/C,IACE,MAAMtH,EAAQwL,EAAW4B,OAAOJ,GAChC,IAAIlG,EAAWmG,EAEXA,IACFnG,EAAW0E,EAAW4B,OAAOH,IAG/BE,EAAcpQ,KAAKnB,KAAKyQ,SAAUrM,EAAO8G,GACzC,MAAOnI,GACP,KAAMA,aAAiB0O,WAAY,MAAM1O,EAEzC,MAAM,IAAI0O,UAAU,mBAAmBzR,KAAK8F,QAAQE,cAAc4J,EAAWlE,WAAW3I,EAAMC,aAKpGiO,uBACE,MAAMN,mBAAEA,GAAuB3Q,KAC/B,OAAOgB,OAAO0C,KAAKiN,GAAoBhO,KAAIgB,GAAOgN,EAAmBhN,KAGvEqN,6BACE,MAAMU,EAAoD,GAO1D,OALA1Q,OAAO0C,KAAK1D,KAAK2Q,oBAAoBtO,SAAQsB,IAC3C,MAAMiM,EAAa5P,KAAK2Q,mBAAmBhN,GAC3C+N,EAAY9B,EAAWlE,MAAQkE,KAG1B8B,EAGDxF,SAASlD,GACf,MACM2I,EAAgB,MAAMlN,EADTzE,KAAKgR,uBAAuBhI,GACG0C,QAElD,OAAO1L,KAAKyQ,SAASkB,UCpHZC,EAMXhS,YAAYkG,EAAkB0B,GAC5BxH,KAAK8F,QAAUA,EACf9F,KAAKwH,SAAWA,EAChBxH,KAAK6R,cAAgB,IAAI9F,EAG3B5J,QACOnC,KAAKuO,oBACRvO,KAAKuO,kBAAoB,IAAI7B,EAAkB1M,KAAKiH,QAASjH,KAAKgJ,cAAehJ,MACjFA,KAAKuO,kBAAkBpM,SAI3BI,OACMvC,KAAKuO,oBACPvO,KAAK8R,uBACL9R,KAAKuO,kBAAkBhM,cAChBvC,KAAKuO,mBAMhBlB,cAAapG,QAAEA,EAASgH,QAASvC,IAC3B1L,KAAKqH,MAAMC,gBAAgBL,IAC7BjH,KAAK+R,cAAc9K,EAASyE,GAIhC4B,gBAAerG,QAAEA,EAASgH,QAASvC,IACjC1L,KAAKgS,iBAAiB/K,EAASyE,GAKjCqG,cAAc9K,EAAkByE,SACzB1L,KAAK6R,cAAcpJ,IAAIiD,EAAMzE,KAChCjH,KAAK6R,cAAcpR,IAAIiL,EAAMzE,aAC7BjH,KAAKuO,kCAAmBnG,OAAM,IAAMpI,KAAKwH,SAASyK,gBAAgBhL,EAASyE,MAI/EsG,iBAAiB/K,EAAkByE,SAC7B1L,KAAK6R,cAAcpJ,IAAIiD,EAAMzE,KAC/BjH,KAAK6R,cAAclR,OAAO+K,EAAMzE,aAChCjH,KAAKuO,kCAAmBnG,OAAM,IAAMpI,KAAKwH,SAAS0K,mBAAmBjL,EAASyE,MAIlFoG,uBACE,IAAK,MAAMpG,KAAQ1L,KAAK6R,cAAcnO,KACpC,IAAK,MAAMuD,KAAWjH,KAAK6R,cAAczF,gBAAgBV,GACvD1L,KAAKgS,iBAAiB/K,EAASyE,GAOrC1C,oBACE,MAAO,QAAQhJ,KAAK8F,QAAQE,oBAG9BiB,cACE,OAAOjH,KAAK8F,QAAQmB,QAGtBI,YACE,OAAOrH,KAAK8F,QAAQuB,aCxEX8K,EAQXvS,YAAYwS,EAAgB/K,GA4E5BrH,sBAAmB,CAACqS,EAAsBpP,EAAiB,MACzD,MAAM+C,WAAEA,EAAUO,WAAEA,EAAUU,QAAEA,GAAYjH,KAC5CiD,EAASjC,OAAOC,OAAO,CAAE+E,WAAAA,EAAYO,WAAAA,EAAYU,QAAAA,GAAWhE,GAC5DjD,KAAK+B,YAAYiF,iBAAiBhH,KAAKgG,WAAYqM,EAAcpP,IA9EjEjD,KAAKoS,OAASA,EACdpS,KAAKqH,MAAQA,EACbrH,KAAKuG,WAAa,IAAI6L,EAAOE,sBAAsBtS,MACnDA,KAAKuS,gBAAkB,IAAIpD,EAAgBnP,KAAMA,KAAKwS,YACtDxS,KAAKyS,cAAgB,IAAIjC,EAAcxQ,KAAMA,KAAKuG,YAClDvG,KAAK0S,eAAiB,IAAId,EAAe5R,KAAMA,MAE/C,IACEA,KAAKuG,WAAWoM,aAChB3S,KAAKgH,iBAAiB,cACtB,MAAOjE,GACP/C,KAAK8C,YAAYC,EAAO,4BAI5B5C,UACEH,KAAKuS,gBAAgBpQ,QACrBnC,KAAKyS,cAActQ,QACnBnC,KAAK0S,eAAevQ,QAEpB,IACEnC,KAAKuG,WAAWpG,UAChBH,KAAKgH,iBAAiB,WACtB,MAAOjE,GACP/C,KAAK8C,YAAYC,EAAO,0BAI5B1C,aACE,IACEL,KAAKuG,WAAWlG,aAChBL,KAAKgH,iBAAiB,cACtB,MAAOjE,GACP/C,KAAK8C,YAAYC,EAAO,4BAG1B/C,KAAK0S,eAAenQ,OACpBvC,KAAKyS,cAAclQ,OACnBvC,KAAKuS,gBAAgBhQ,OAGvBR,kBACE,OAAO/B,KAAKoS,OAAOrQ,YAGrBiE,iBACE,OAAOhG,KAAKoS,OAAOpM,WAGrBwJ,aACE,OAAOxP,KAAK+B,YAAYyN,OAG1BgD,iBACE,OAAOxS,KAAK+B,YAAYyQ,WAG1BvL,cACE,OAAOjH,KAAKqH,MAAMJ,QAGpB2L,oBACE,OAAO5S,KAAKiH,QAAQ2L,cAKtB9P,YAAYC,EAAcC,EAAiBC,EAAiB,IAC1D,MAAM+C,WAAEA,EAAUO,WAAEA,EAAUU,QAAEA,GAAYjH,KAC5CiD,EAASjC,OAAOC,OAAO,CAAE+E,WAAAA,EAAYO,WAAAA,EAAYU,QAAAA,GAAWhE,GAC5DjD,KAAK+B,YAAYe,YAAYC,EAAO,SAASC,IAAWC,GAa1DgP,gBAAgBhL,EAAkByE,GAChC1L,KAAK6S,uBAAuB,GAAGnH,mBAAuBzE,GAGxDiL,mBAAmBjL,EAAkByE,GACnC1L,KAAK6S,uBAAuB,GAAGnH,sBAA0BzE,GAK3D4L,uBAAuBrM,KAAuBsM,GAC5C,MAAMvM,EAAkBvG,KAAKuG,WACQ,mBAA1BA,EAAWC,IACpBD,EAAWC,MAAesM,aClHhBC,EAAgDnT,EAA6BoT,GAC3F,MAAMC,EAAYC,EAA2BtT,GAC7C,OAAO0B,MAAMC,KAAK0R,EAAUxQ,QAAO,CAACD,EAAQ5C,KAuB9C,SAAoCA,EAA6BoT,GAC/D,MAAMG,EAAcvT,EAAoBoT,GACxC,OAAO1R,MAAM8R,QAAQD,GAAcA,EAAa,GAxB9CE,CAAwBzT,EAAaoT,GAAc3Q,SAAQqJ,GAAQlJ,EAAO/B,IAAIiL,KACvElJ,IACN,IAAItC,eAGOoT,EAAuC1T,EAA6BoT,GAElF,OADkBE,EAA2BtT,GAC5B6C,QAAO,CAAC8Q,EAAO3T,KAC9B2T,EAAM3P,QAmBV,SAAuChE,EAA6BoT,GAClE,MAAMG,EAAcvT,EAAoBoT,GACxC,OAAOG,EAAanS,OAAO0C,KAAKyP,GAAYxQ,KAAIgB,GAAO,CAACA,EAAKwP,EAAWxP,MAAwB,GArBhF6P,CAAwB5T,EAAaoT,IAC5CO,IACN,IAGL,SAASL,EAA8BtT,GACrC,MAAMqT,EAA+B,GACrC,KAAOrT,GACLqT,EAAUrP,KAAKhE,GACfA,EAAcoB,OAAOyS,eAAe7T,GAEtC,OAAOqT,EAAUS,mBCfHC,EAAS/T,GACvB,OAGF,SAAmBA,EAA6BgU,GAC9C,MAAMC,EAAoBC,EAAOlU,GAC3BmU,EAiBR,SAAgCC,EAAgBJ,GAC9C,OAAOK,EAAWL,GAAYnR,QAAO,CAACsR,EAAkBpQ,KACtD,MAAMiM,EAQV,SAA+BoE,EAAgBJ,EAAmCjQ,GAChF,MAAMuQ,EAAsBlT,OAAOmT,yBAAyBH,EAAWrQ,GAEvE,IADwBuQ,KAAuB,UAAWA,GACpC,CACpB,MAAMtE,EAAa5O,OAAOmT,yBAAyBP,EAAYjQ,GAAMS,MAKrE,OAJI8P,IACFtE,EAAWtM,IAAM4Q,EAAoB5Q,KAAOsM,EAAWtM,IACvDsM,EAAWpM,IAAM0Q,EAAoB1Q,KAAOoM,EAAWpM,KAElDoM,GAjBYwE,CAAsBJ,EAAWJ,EAAYjQ,GAIhE,OAHIiM,GACF5O,OAAOC,OAAO8S,EAAkB,CAAEpQ,CAACA,GAAMiM,IAEpCmE,IACN,IAxBsBM,CAAoBzU,EAAYoU,UAAWJ,GAEpE,OADA5S,OAAOsT,iBAAiBT,EAAkBG,UAAWD,GAC9CF,EAPAU,CAAO3U,EAUhB,SAAiCA,GAE/B,OADkBmT,EAAiCnT,EAAa,aAC/C6C,QAAO,CAAC+R,EAAmBC,KAC1C,MAAMb,EAAaa,EAAS7U,GAC5B,IAAK,MAAM+D,KAAOiQ,EAAY,CAC5B,MAAMhE,EAAa4E,EAAkB7Q,IAAQ,GAC7C6Q,EAAkB7Q,GAAO3C,OAAOC,OAAO2O,EAAYgE,EAAWjQ,IAEhE,OAAO6Q,IACN,IAnBwBE,CAAqB9U,IA6ClD,MAAMqU,EACuC,mBAAhCjT,OAAO2T,sBACRC,GAAgB,IACnB5T,OAAO6T,oBAAoBD,MAC3B5T,OAAO2T,sBAAsBC,IAG3B5T,OAAO6T,oBAIZf,EAAS,MACb,SAASgB,EAA6ClV,GACpD,SAASmV,IACP,OAAOC,QAAQC,UAAUrV,EAAasV,sBAQxC,OALAH,EAASf,UAAYhT,OAAOmU,OAAOvV,EAAYoU,UAAW,CACxDpU,YAAa,CAAEwE,MAAO2Q,KAGxBC,QAAQI,eAAeL,EAAUnV,GAC1BmV,EAUT,IAEE,OATF,WACE,MACMM,EAAIP,GADA,WAAsB9U,KAAK+E,EAAE5D,KAAKnB,SAE5CqV,EAAErB,UAAUjP,EAAI,aACT,IAAIsQ,EAIXC,GACOR,EACP,MAAO/R,GACP,OAAmCnD,GAAmB,cAAuBA,MAzBlE,SC5DF2V,EAMX3V,YAAYmC,EAA0BoR,GACpCnT,KAAK+B,YAAcA,EACnB/B,KAAKmT,oBCNuBA,GAC9B,MAAO,CACLnN,WAAYmN,EAAWnN,WACvBsM,sBAAuBqB,EAAMR,EAAWb,wBDGtBkD,CAAgBrC,GAClCnT,KAAKyV,gBAAkB,IAAIhH,QAC3BzO,KAAK0V,kBAAoB,IAAIxV,IAG/B8F,iBACE,OAAOhG,KAAKmT,WAAWnN,WAGzBsM,4BACE,OAAOtS,KAAKmT,WAAWb,sBAGzBqD,eACE,OAAOrU,MAAMC,KAAKvB,KAAK0V,mBAGzBE,uBAAuBvO,GACrB,MAAMvB,EAAU9F,KAAK6V,qBAAqBxO,GAC1CrH,KAAK0V,kBAAkBjV,IAAIqF,GAC3BA,EAAQ3F,UAGV2V,0BAA0BzO,GACxB,MAAMvB,EAAU9F,KAAKyV,gBAAgBnS,IAAI+D,GACrCvB,IACF9F,KAAK0V,kBAAkB/U,OAAOmF,GAC9BA,EAAQzF,cAIJwV,qBAAqBxO,GAC3B,IAAIvB,EAAU9F,KAAKyV,gBAAgBnS,IAAI+D,GAKvC,OAJKvB,IACHA,EAAU,IAAIqM,EAAQnS,KAAMqH,GAC5BrH,KAAKyV,gBAAgBjS,IAAI6D,EAAOvB,IAE3BA,SEhDEiQ,EAGXnW,YAAYyH,GACVrH,KAAKqH,MAAQA,EAGfoB,IAAIiD,GACF,OAAO1L,KAAKmR,KAAK1I,IAAIzI,KAAKgW,WAAWtK,IAGvCpI,IAAIoI,GACF,OAAO1L,KAAKiW,OAAOvK,GAAM,GAG3BuK,OAAOvK,GACL,MAAMwC,EAAclO,KAAKmR,KAAK7N,IAAItD,KAAKgW,WAAWtK,KAAU,GAC5D,OAAgBwC,EnBPL1D,MAAM,YAAc,GmBUjC0L,iBAAiBxK,GACf,OAAO1L,KAAKmR,KAAKgF,uBAAuBnW,KAAKgW,WAAWtK,IAG1DsK,WAAWtK,GACT,MAAO,GAAGA,UAGZyF,WACE,OAAOnR,KAAKqH,MAAM8J,YC7BTiF,EAGXxW,YAAYyH,GACVrH,KAAKqH,MAAQA,EAGfJ,cACE,OAAOjH,KAAKqH,MAAMJ,QAGpBjB,iBACE,OAAOhG,KAAKqH,MAAMrB,WAGpB1C,IAAIK,GACF,MAAM+H,EAAO1L,KAAKmW,uBAAuBxS,GACzC,OAAO3D,KAAKiH,QAAQ5B,aAAaqG,GAGnClI,IAAIG,EAAaS,GACf,MAAMsH,EAAO1L,KAAKmW,uBAAuBxS,GAEzC,OADA3D,KAAKiH,QAAQoP,aAAa3K,EAAMtH,GACzBpE,KAAKsD,IAAIK,GAGlB8E,IAAI9E,GACF,MAAM+H,EAAO1L,KAAKmW,uBAAuBxS,GACzC,OAAO3D,KAAKiH,QAAQsD,aAAamB,GAGnC/K,OAAOgD,GACL,GAAI3D,KAAKyI,IAAI9E,GAAM,CACjB,MAAM+H,EAAO1L,KAAKmW,uBAAuBxS,GAEzC,OADA3D,KAAKiH,QAAQqP,gBAAgB5K,IACtB,EAEP,OAAO,EAIXyK,uBAAuBxS,GACrB,MAAO,QAAQ3D,KAAKgG,cAAcpB,EAAUjB,YC3CnC4S,EAIX3W,YAAY4W,GAFHxW,wBAAgD,IAAIyO,QAG3DzO,KAAKwW,OAASA,EAGhBC,KAAK7B,EAAajR,EAAaX,GAC7B,IAAI0T,EAAsC1W,KAAK2W,mBAAmBrT,IAAIsR,GAEjE8B,IACHA,EAAa,IAAIxW,IACjBF,KAAK2W,mBAAmBnT,IAAIoR,EAAQ8B,IAGjCA,EAAWjO,IAAI9E,KAClB+S,EAAWjW,IAAIkD,GACf3D,KAAKwW,OAAOC,KAAKzT,EAAS4R,cCpBhBgC,EAA4B5N,EAAuBoE,GACjE,MAAO,IAAIpE,OAAmBoE,YCEnByJ,EAGXjX,YAAYyH,GACVrH,KAAKqH,MAAQA,EAGfJ,cACE,OAAOjH,KAAKqH,MAAMJ,QAGpBjB,iBACE,OAAOhG,KAAKqH,MAAMrB,WAGpBwJ,aACE,OAAOxP,KAAKqH,MAAMmI,OAGpB/G,IAAIqO,GACF,OAAgC,MAAzB9W,KAAK+W,KAAKD,GAGnBC,QAAQC,GACN,OAAOA,EAAYvU,QAAO,CAACmE,EAAQkQ,IAC9BlQ,GACA5G,KAAKiX,WAAWH,IAChB9W,KAAKkX,iBAAiBJ,SACzB5F,GAGJiG,WAAWH,GACT,OAAOA,EAAYvU,QAAO,CAAC2U,EAASN,IAAe,IAC9CM,KACApX,KAAKqX,eAAeP,MACpB9W,KAAKsX,qBAAqBR,KAC5B,IAGGG,WAAWH,GACjB,MAAMxM,EAAWtK,KAAKuX,yBAAyBT,GAC/C,OAAO9W,KAAKqH,MAAMmQ,YAAYlN,GAGxB+M,eAAeP,GACrB,MAAMxM,EAAWtK,KAAKuX,yBAAyBT,GAC/C,OAAO9W,KAAKqH,MAAMoQ,gBAAgBnN,GAG5BiN,yBAAyBT,GAE/B,OAAOF,EADe5W,KAAKwP,OAAOkI,wBAAwB1X,KAAKgG,YACb8Q,GAG5CI,iBAAiBJ,GACvB,MAAMxM,EAAWtK,KAAK2X,+BAA+Bb,GACrD,OAAO9W,KAAK4X,UAAU5X,KAAKqH,MAAMmQ,YAAYlN,GAAWwM,GAGlDQ,qBAAqBR,GAC3B,MAAMxM,EAAWtK,KAAK2X,+BAA+Bb,GACrD,OAAO9W,KAAKqH,MAAMoQ,gBAAgBnN,GAAU3H,KAAIsE,GAAWjH,KAAK4X,UAAU3Q,EAAS6P,KAG7Ea,+BAA+Bb,GACrC,MAAMe,EAAmB,GAAG7X,KAAKgG,cAAc8Q,IAC/C,OAAOF,EAA4B5W,KAAKwP,OAAOsI,gBAAiBD,GAG1DD,UAAa3Q,EAAY6P,GAC/B,GAAI7P,EAAS,CACX,MAAMjB,WAAEA,GAAehG,KACjBgJ,EAAgBhJ,KAAKwP,OAAOsI,gBAC5BC,EAAuB/X,KAAKwP,OAAOkI,wBAAwB1R,GACjEhG,KAAKgY,MAAMvB,KAAKxP,EAAS,UAAU6P,IACjC,kBAAkB9N,MAAkBhD,KAAc8Q,WAAoBiB,MAAyBjB,WACxF9N,kFAEX,OAAO/B,EAGT+Q,YACE,OAAOhY,KAAKqH,MAAM2Q,aC7ETC,EASXrY,YAAY4P,EAAgBvI,EAAkBjB,EAAoBwQ,GAJzDxW,aAAU,IAAI6W,EAAU7W,MACxBA,aAAU,IAAI+V,EAAS/V,MACvBA,UAAO,IAAIoW,EAAQpW,MAsB5BA,qBAAmBiH,GACVA,EAAQiR,QAAQlY,KAAKmY,sBAAwBnY,KAAKiH,QApBzDjH,KAAKwP,OAASA,EACdxP,KAAKiH,QAAUA,EACfjH,KAAKgG,WAAaA,EAClBhG,KAAKgY,MAAQ,IAAIzB,EAAMC,GAGzBgB,YAAYlN,GACV,OAAOtK,KAAKiH,QAAQsB,QAAQ+B,GACxBtK,KAAKiH,QACLjH,KAAKoY,cAAc9N,GAAUyM,KAAK/W,KAAKsH,iBAG7CmQ,gBAAgBnN,GACd,MAAO,IACFtK,KAAKiH,QAAQsB,QAAQ+B,GAAY,CAACtK,KAAKiH,SAAW,MAClDjH,KAAKoY,cAAc9N,GAAUgC,OAAOtM,KAAKsH,kBAQxC8Q,cAAc9N,GACpB,OAAOhJ,MAAMC,KAAKvB,KAAKiH,QAAQwD,iBAAiBH,IAGlD6N,yBACE,OAAOvB,EAA4B5W,KAAKwP,OAAO6I,oBAAqBrY,KAAKgG,mBCnChEsS,EAQX1Y,YAAYqH,EAAkBuI,EAAgBhI,GAC5CxH,KAAKiH,QAAUA,EACfjH,KAAKwP,OAASA,EACdxP,KAAKwH,SAAWA,EAChBxH,KAAKqP,kBAAoB,IAAIf,EAAkBtO,KAAKiH,QAASjH,KAAKqY,oBAAqBrY,MACvFA,KAAKuY,4BAA8B,IAAI9J,QACvCzO,KAAKwY,qBAAuB,IAAI/J,QAGlCtM,QACEnC,KAAKqP,kBAAkBlN,QAGzBI,OACEvC,KAAKqP,kBAAkB9M,OAGzB8V,0BACE,OAAOrY,KAAKwP,OAAO6I,oBAKrBnJ,mBAAmB9B,GACjB,MAAMnG,QAAEA,EAASgH,QAASjI,GAAeoH,EACnCqL,EAAqBzY,KAAK0Y,kCAAkCzR,GAElE,IAAII,EAAQoR,EAAmBnV,IAAI0C,GAMnC,OALKqB,IACHA,EAAQrH,KAAKwH,SAASmR,mCAAmC1R,EAASjB,GAClEyS,EAAmBjV,IAAIwC,EAAYqB,IAG9BA,EAGTwH,oBAAoB5H,EAAkB7C,GACpC,MAAMwU,GAAkB5Y,KAAKwY,qBAAqBlV,IAAIc,IAAU,GAAK,EACrEpE,KAAKwY,qBAAqBhV,IAAIY,EAAOwU,GACf,GAAlBA,GACF5Y,KAAKwH,SAASqR,eAAezU,GAIjC0K,sBAAsB7H,EAAkB7C,GACtC,MAAMwU,EAAiB5Y,KAAKwY,qBAAqBlV,IAAIc,GACjDwU,IACF5Y,KAAKwY,qBAAqBhV,IAAIY,EAAOwU,EAAiB,GAChC,GAAlBA,GACF5Y,KAAKwH,SAASsR,kBAAkB1U,IAK9BsU,kCAAkCzR,GACxC,IAAIwR,EAAqBzY,KAAKuY,4BAA4BjV,IAAI2D,GAK9D,OAJKwR,IACHA,EAAqB,IAAIxW,IACzBjC,KAAKuY,4BAA4B/U,IAAIyD,EAASwR,IAEzCA,SCvEEM,EAMXnZ,YAAYmC,GACV/B,KAAK+B,YAAcA,EACnB/B,KAAKgZ,cAAgB,IAAIV,EAActY,KAAKiH,QAASjH,KAAKwP,OAAQxP,MAClEA,KAAKyY,mBAAqB,IAAI1M,EAC9B/L,KAAKiZ,oBAAsB,IAAIhX,IAGjCgF,cACE,OAAOjH,KAAK+B,YAAYkF,QAG1BuI,aACE,OAAOxP,KAAK+B,YAAYyN,OAG1BgH,aACE,OAAOxW,KAAK+B,YAAYyU,OAG1B6B,0BACE,OAAOrY,KAAKwP,OAAO6I,oBAGrBa,cACE,OAAO5X,MAAMC,KAAKvB,KAAKiZ,oBAAoBzW,UAG7CmT,eACE,OAAO3V,KAAKkZ,QAAQzW,QAAO,CAACkT,EAAUvD,IAAWuD,EAAS/S,OAAOwP,EAAOuD,WAAW,IAGrFxT,QACEnC,KAAKgZ,cAAc7W,QAGrBI,OACEvC,KAAKgZ,cAAczW,OAGrB4W,eAAehG,GACbnT,KAAKoZ,iBAAiBjG,EAAWnN,YACjC,MAAMoM,EAAS,IAAImD,EAAOvV,KAAK+B,YAAaoR,GAC5CnT,KAAKqZ,cAAcjH,GAGrBgH,iBAAiBpT,GACf,MAAMoM,EAASpS,KAAKiZ,oBAAoB3V,IAAI0C,GACxCoM,GACFpS,KAAKsZ,iBAAiBlH,GAI1BmH,kCAAkCtS,EAAkBjB,GAClD,MAAMoM,EAASpS,KAAKiZ,oBAAoB3V,IAAI0C,GAC5C,GAAIoM,EACF,OAAOA,EAAOuD,SAASoB,MAAKjR,GAAWA,EAAQmB,SAAWA,IAM9DnE,YAAYC,EAAcC,EAAiBC,GACzCjD,KAAK+B,YAAYe,YAAYC,EAAOC,EAASC,GAK/C0V,mCAAmC1R,EAAkBjB,GACnD,OAAO,IAAIiS,EAAMjY,KAAKwP,OAAQvI,EAASjB,EAAYhG,KAAKwW,QAG1DqC,eAAexR,GACbrH,KAAKyY,mBAAmBhY,IAAI4G,EAAMrB,WAAYqB,GAC9C,MAAM+K,EAASpS,KAAKiZ,oBAAoB3V,IAAI+D,EAAMrB,YAC9CoM,GACFA,EAAOwD,uBAAuBvO,GAIlCyR,kBAAkBzR,GAChBrH,KAAKyY,mBAAmB9X,OAAO0G,EAAMrB,WAAYqB,GACjD,MAAM+K,EAASpS,KAAKiZ,oBAAoB3V,IAAI+D,EAAMrB,YAC9CoM,GACFA,EAAO0D,0BAA0BzO,GAM7BgS,cAAcjH,GACpBpS,KAAKiZ,oBAAoBzV,IAAI4O,EAAOpM,WAAYoM,GACjCpS,KAAKyY,mBAAmBrM,gBAAgBgG,EAAOpM,YACvD3D,SAAQgF,GAAS+K,EAAOwD,uBAAuBvO,KAGhDiS,iBAAiBlH,GACvBpS,KAAKiZ,oBAAoBtY,OAAOyR,EAAOpM,YACxBhG,KAAKyY,mBAAmBrM,gBAAgBgG,EAAOpM,YACvD3D,SAAQgF,GAAS+K,EAAO0D,0BAA0BzO,YCzGhDmS,EAAwB,CACnCnB,oBAAqB,kBACrB/I,gBAAiB,cACjBwI,gBAAiB,cACjBJ,wBAAyB1R,GAAc,QAAQA,kBCHpCyT,EAcX7Z,YAAYqH,EAAmB/C,SAASwV,gBAAiBlK,EAAiBgK,GAT1ExZ,YAAiB2Z,QACjB3Z,YAAiB,EAyEjBA,sBAAmB,CAACgG,EAAoBqM,EAAsBpP,EAAiB,MACzEjD,KAAK4Z,OACP5Z,KAAK6Z,oBAAoB7T,EAAYqM,EAAcpP,IAlErDjD,KAAKiH,QAAUA,EACfjH,KAAKwP,OAASA,EACdxP,KAAKwS,WAAa,IAAI1Q,EAAW9B,MACjCA,KAAK8Z,OAAS,IAAIf,EAAO/Y,MAV3BmC,aAAa8E,EAAmBuI,GAC9B,MAAMzN,EAAc,IAAI0X,EAAYxS,EAASuI,GAE7C,OADAzN,EAAYI,QACLJ,EAUTI,oBA0EO,IAAI4X,SAAcC,IACI,WAAvB9V,SAAS+V,WACX/V,SAAS9D,iBAAiB,oBAAoB,IAAM4Z,MAEpDA,OA5EFha,KAAKgH,iBAAiB,cAAe,YACrChH,KAAKwS,WAAWrQ,QAChBnC,KAAK8Z,OAAO3X,QACZnC,KAAKgH,iBAAiB,cAAe,SAGvCzE,OACEvC,KAAKgH,iBAAiB,cAAe,YACrChH,KAAKwS,WAAWjQ,OAChBvC,KAAK8Z,OAAOvX,OACZvC,KAAKgH,iBAAiB,cAAe,QAGvCkT,SAASlU,EAAoBsM,GAC3BtS,KAAKma,KAAK,CAAEnU,WAAAA,EAAYsM,sBAAAA,IAK1B6H,KAAKC,KAAoCC,IACnB/Y,MAAM8R,QAAQgH,GAAQA,EAAO,CAACA,KAASC,IAC/ChY,SAAQ8Q,IACbA,EAAWb,sBAA8BgI,YAC5Cta,KAAK8Z,OAAOX,eAAehG,MAOjCoH,OAAOH,KAA4BC,IACb/Y,MAAM8R,QAAQgH,GAAQA,EAAO,CAACA,KAASC,IAC/ChY,SAAQ2D,GAAchG,KAAK8Z,OAAOV,iBAAiBpT,KAKjEwU,kBACE,OAAOxa,KAAK8Z,OAAOnE,SAAShT,KAAImD,GAAWA,EAAQS,aAGrDkU,qCAAqCxT,EAAkBjB,GACrD,MAAMF,EAAU9F,KAAK8Z,OAAOP,kCAAkCtS,EAASjB,GACvE,OAAOF,EAAUA,EAAQS,WAAa,KAKxCzD,YAAYC,EAAcC,EAAiBC,SACzCjD,KAAKwW,OAAOzT,MAAM,iBAAkBC,EAASD,EAAOE,aAEpDgB,OAAOyW,6BAAPzW,OAAiBjB,EAAS,GAAI,EAAG,EAAGD,GAW9B8W,oBAAoB7T,EAAoBqM,EAAsBpP,EAAiB,IACrFA,EAASjC,OAAOC,OAAO,CAAEc,YAAa/B,MAAQiD,GAE9CjD,KAAKwW,OAAOmE,eAAe,GAAG3U,MAAeqM,KAC7CrS,KAAKwW,OAAOoE,IAAI,4BAAiB3X,IACjCjD,KAAKwW,OAAOqE,YChBhB,SAASC,GAA0B1N,EAAO2N,GAAsCxU,GAC9E,OAyEF,SAAkDyU,GAChD,MAAMrX,EAAM,GAAGiB,EAAUoW,EAAQ5N,eAC3BtE,EA/BR,SAAkCkS,GAChC,MAAMC,EAjBR,SAA8BD,GAC5B,MAAMC,EAAiBC,EAAuBF,EAAQG,WAAWrS,MAEjE,IAAKmS,EAAgB,OAErB,MAAMG,EAAmBC,EAAsBL,EAAQG,WAAWG,SAElE,GAAIL,IAAmBG,EAAkB,CACvC,MAAMG,EAAeP,EAAQzU,WAAa,GAAGyU,EAAQzU,cAAcyU,EAAQ5N,QAAU4N,EAAQ5N,MAE7F,MAAM,IAAI5H,MAAM,uDAAuD+V,mCAA8CN,sCAAmDD,EAAQG,WAAWG,wBAAwBF,OAGrN,OAAOH,EAIgBO,CAAqB,CAC1CjV,WAAYyU,EAAQzU,WACpB6G,MAAO4N,EAAQ5N,MACf+N,WAAYH,EAAQD,iBAEhBU,EAAuBJ,EAAsBL,EAAQD,gBACrDW,EAAmBR,EAAuBF,EAAQD,gBAElDjS,EAAOmS,GAAkBQ,GAAwBC,EAEvD,GAAI5S,EAAM,OAAOA,EAEjB,MAAMyS,EAAeP,EAAQzU,WAAa,GAAGyU,EAAQzU,cAAcyU,EAAQD,iBAAmBC,EAAQ5N,MAEtG,MAAM,IAAI5H,MAAM,uBAAuB+V,WAAsBP,EAAQ5N,gBAgBxDuO,CAAyBX,GACtC,MAAO,CACLlS,KAAAA,EACAnF,IAAAA,EACA+H,KAAMvH,EAASR,GACfoN,mBAAqB,OAlBzB,SAAmCgK,GACjC,MAAMa,EAAWV,EAAuBH,GAExC,GAAIa,EAAU,OAAOC,EAAoBD,GAEzC,MAAM7K,EAAgBgK,EAAmCO,QACzD,YAAqBpK,IAAjBH,EAAmCA,EAEhCgK,EAUuBe,CAA0Bd,EAAQD,iBAC9DgB,4BAA8B,YAAyD7K,IAAlDmK,EAAsBL,EAAQD,iBACnEvJ,OAAQwK,EAAQlT,GAChBgI,OAAQmL,EAAQnT,IAASmT,EAAQX,SAnF5BY,CAAyC,CAC9C3V,WAAAA,EACA6G,MAAAA,EACA2N,eAAAA,IAIJ,SAASG,EAAuBU,GAC9B,OAAQA,GACN,KAAKta,MAAS,MAAO,QACrB,KAAK6a,QAAS,MAAO,UACrB,KAAKC,OAAS,MAAO,SACrB,KAAKpb,OAAS,MAAO,SACrB,KAAKqb,OAAS,MAAO,UAIzB,SAAShB,EAAsBtK,GAC7B,cAAeA,GACb,IAAK,UAAW,MAAO,UACvB,IAAK,SAAW,MAAO,SACvB,IAAK,SAAW,MAAO,SAGzB,OAAIzP,MAAM8R,QAAQrC,GAAsB,QACa,oBAAjD/P,OAAOgT,UAAU5D,SAASjP,KAAK4P,GAA4C,cAA/E,EA8DF,MAAM8K,EAAsB,CAC1BS,YAAc,MAAO,IACrBC,SAAS,EACTC,OAAQ,EACR5H,aAAe,MAAO,IACtB6H,OAAQ,IAKJT,EAAsC,CAC1CM,MAAMlY,GACJ,MAAMkY,EAAQ5W,KAAKC,MAAMvB,GACzB,IAAK9C,MAAM8R,QAAQkJ,GACjB,MAAM,IAAI7K,UAAU,yDAAyDrN,eAAmBiX,EAAsBiB,OAExH,OAAOA,GAGTC,QAAQnY,KACY,KAATA,GAA+C,SAA/BiY,OAAOjY,GAAOS,eAGzC2X,OAAOpY,GACEgY,OAAOhY,GAGhBwQ,OAAOxQ,GACL,MAAMwQ,EAASlP,KAAKC,MAAMvB,GAC1B,GAAe,OAAXwQ,GAAoC,iBAAVA,GAAsBtT,MAAM8R,QAAQwB,GAChE,MAAM,IAAInD,UAAU,0DAA0DrN,eAAmBiX,EAAsBzG,OAEzH,OAAOA,GAGT6H,OAAOrY,GACEA,GAML6X,EAAsC,CAC1CX,QASF,SAAqBlX,GACnB,MAAO,GAAGA,KATVkY,MAAOI,EACP9H,OAAQ8H,GAGV,SAASA,EAAUtY,GACjB,OAAOsB,KAAKiX,UAAUvY,SCnNXwY,EAWXhd,YAAYkG,GACV9F,KAAK8F,QAAUA,EAPjBwU,wBACE,OAAO,EASTvY,kBACE,OAAO/B,KAAK8F,QAAQ/D,YAGtBsF,YACE,OAAOrH,KAAK8F,QAAQuB,MAGtBJ,cACE,OAAOjH,KAAKqH,MAAMJ,QAGpBjB,iBACE,OAAOhG,KAAKqH,MAAMrB,WAGpBoR,cACE,OAAOpX,KAAKqH,MAAM+P,QAGpByF,cACE,OAAO7c,KAAKqH,MAAMwV,QAGpB1L,WACE,OAAOnR,KAAKqH,MAAM8J,KAGpBwB,cAIAxS,WAIAE,cAIAyc,SAAShd,GAAmB8G,OAAEA,EAAS5G,KAAKiH,QAAOhE,OAAEA,EAAS,GAAE8Z,OAAEA,EAAS/c,KAAKgG,WAAUgX,QAAEA,GAAU,EAAIC,WAAEA,GAAa,GAAS,IAChI,MACMpc,EAAQ,IAAIqc,YADLH,EAAS,GAAGA,KAAUjd,IAAcA,EACb,CAAEmD,OAAAA,EAAQ+Z,QAAAA,EAASC,WAAAA,IAEvD,OADArW,EAAOuW,cAActc,GACdA,GA1DF+b,YAAY,UCJsBhd,GAEzC,OADgBmT,EAAiCnT,EAAa,WAC/C6C,QAAO,CAACmR,EAAYwJ,KACjC,OAAOpc,OAAOC,OAAO2S,EAKhB,CACL,CAAC,GAFiCjQ,EAJ4ByZ,UAM7C,CACf9Z,MACE,MAAMuZ,QAAEA,GAAY7c,KACpB,GAAI6c,EAAQpU,IAAI9E,GACd,OAAOkZ,EAAQvZ,IAAIK,GACd,CACL,MAAM8H,EAAYoR,EAAQ3G,iBAAiBvS,GAC3C,MAAM,IAAI6B,MAAM,sBAAsBiG,SAK5C,CAAC,GAAG9H,YAAe,CACjBL,MACE,OAAOtD,KAAK6c,QAAQ5G,OAAOtS,KAI/B,CAAC,MAAMc,EAAWd,WAAc,CAC9BL,MACE,OAAOtD,KAAK6c,QAAQpU,IAAI9E,OAtBhC,IAAsCA,IAHjC,cCJuC/D,GAE1C,OADgBmT,EAAiCnT,EAAa,WAC/C6C,QAAO,CAACmR,EAAYyJ,KACjC,OAAOrc,OAAOC,OAAO2S,EAKhB,CACL,CAAC,GAFkClI,EAJ4B2R,WAM5C,CACjB/Z,MACE,MAAMsD,EAAS5G,KAAKoX,QAAQL,KAAKrL,GACjC,GAAI9E,EACF,OAAOA,EAEP,MAAM,IAAIpB,MAAM,2BAA2BkG,WAAc1L,KAAKgG,4BAKpE,CAAC,GAAG0F,YAAgB,CAClBpI,MACE,OAAOtD,KAAKoX,QAAQD,QAAQzL,KAIhC,CAAC,MAAMjH,EAAWiH,YAAgB,CAChCpI,MACE,OAAOtD,KAAKoX,QAAQ3O,IAAIiD,OArBhC,IAAuCA,IAHlC,cHJsC9L,GACzC,MAAM0d,EAAuBhK,EAAyD1T,EAAa,UAC7F2d,EAA+C,CACnD5M,mBAAoB,CAClBrN,MACE,OAAOga,EAAqB7a,QAAO,CAAC+a,EAAQC,KAC1C,MAAMC,EAAkB5C,EAAyB2C,EAAqBzd,KAAKgG,YACrEgD,EAAgBhJ,KAAKmR,KAAKgF,uBAAuBuH,EAAgB/Z,KACvE,OAAO3C,OAAOC,OAAOuc,EAAQ,CAAExU,CAACA,GAAgB0U,MAC/C,OAKT,OAAOJ,EAAqB7a,QAAO,CAACmR,EAAY6J,IACvCzc,OAAOC,OAAO2S,WAI2B6J,EAA0ClX,GAC5F,MAAM4M,EAAa2H,EAAyB2C,EAAqBlX,IAC3D5C,IAAEA,EAAG+H,KAAEA,EAAM8F,OAAQmM,EAAM7M,OAAQ8M,GAAUzK,EAEnD,MAAO,CACLzH,CAACA,GAAO,CACNpI,MACE,MAAMc,EAAQpE,KAAKmR,KAAK7N,IAAIK,GAC5B,OAAc,OAAVS,EACKuZ,EAAKvZ,GAEL+O,EAAWpC,cAItBvN,IAAsBY,QACN8M,IAAV9M,EACFpE,KAAKmR,KAAKxQ,OAAOgD,GAEjB3D,KAAKmR,KAAK3N,IAAIG,EAAKia,EAAMxZ,MAK/B,CAAC,MAAMK,EAAWiH,MAAU,CAC1BpI,MACE,OAAOtD,KAAKmR,KAAK1I,IAAI9E,IAAQwP,EAAW4I,yBA9BX8B,CAAiCJ,KACjEF,KCXIX,UAAoB,GACpBA,SAA6B"}