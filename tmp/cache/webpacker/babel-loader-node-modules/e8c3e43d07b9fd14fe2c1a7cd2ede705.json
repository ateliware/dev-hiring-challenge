{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\r\n * Bootstrap-select v1.13.18 (https://developer.snapappointments.com/bootstrap-select)\r\n *\r\n * Copyright 2012-2020 SnapAppointments, LLC\r\n * Licensed under MIT (https://github.com/snapappointments/bootstrap-select/blob/master/LICENSE)\r\n */\n(function (root, factory) {\n  if (root === undefined && window !== undefined) root = window;\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define([\"jquery\"], function (a0) {\n      return factory(a0);\n    });\n  } else if ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory(require(\"jquery\"));\n  } else {\n    factory(root[\"jQuery\"]);\n  }\n})(this, function (jQuery) {\n  (function ($) {\n    'use strict';\n\n    var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];\n    var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];\n    var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n    var DefaultWhitelist = {\n      // Global attributes allowed on any supplied element below.\n      '*': ['class', 'dir', 'id', 'lang', 'role', 'tabindex', 'style', ARIA_ATTRIBUTE_PATTERN],\n      a: ['target', 'href', 'title', 'rel'],\n      area: [],\n      b: [],\n      br: [],\n      col: [],\n      code: [],\n      div: [],\n      em: [],\n      hr: [],\n      h1: [],\n      h2: [],\n      h3: [],\n      h4: [],\n      h5: [],\n      h6: [],\n      i: [],\n      img: ['src', 'alt', 'title', 'width', 'height'],\n      li: [],\n      ol: [],\n      p: [],\n      pre: [],\n      s: [],\n      small: [],\n      span: [],\n      sub: [],\n      sup: [],\n      strong: [],\n      u: [],\n      ul: []\n    };\n    /**\r\n     * A pattern that recognizes a commonly useful subset of URLs that are safe.\r\n     *\r\n     * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\r\n     */\n\n    var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n    /**\r\n     * A pattern that matches safe data URLs. Only matches image, video and audio types.\r\n     *\r\n     * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\r\n     */\n\n    var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;\n\n    function allowedAttribute(attr, allowedAttributeList) {\n      var attrName = attr.nodeName.toLowerCase();\n\n      if ($.inArray(attrName, allowedAttributeList) !== -1) {\n        if ($.inArray(attrName, uriAttrs) !== -1) {\n          return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));\n        }\n\n        return true;\n      }\n\n      var regExp = $(allowedAttributeList).filter(function (index, value) {\n        return value instanceof RegExp;\n      }); // Check if a regular expression validates the attribute.\n\n      for (var i = 0, l = regExp.length; i < l; i++) {\n        if (attrName.match(regExp[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function sanitizeHtml(unsafeElements, whiteList, sanitizeFn) {\n      if (sanitizeFn && typeof sanitizeFn === 'function') {\n        return sanitizeFn(unsafeElements);\n      }\n\n      var whitelistKeys = Object.keys(whiteList);\n\n      for (var i = 0, len = unsafeElements.length; i < len; i++) {\n        var elements = unsafeElements[i].querySelectorAll('*');\n\n        for (var j = 0, len2 = elements.length; j < len2; j++) {\n          var el = elements[j];\n          var elName = el.nodeName.toLowerCase();\n\n          if (whitelistKeys.indexOf(elName) === -1) {\n            el.parentNode.removeChild(el);\n            continue;\n          }\n\n          var attributeList = [].slice.call(el.attributes);\n          var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);\n\n          for (var k = 0, len3 = attributeList.length; k < len3; k++) {\n            var attr = attributeList[k];\n\n            if (!allowedAttribute(attr, whitelistedAttributes)) {\n              el.removeAttribute(attr.nodeName);\n            }\n          }\n        }\n      }\n    } // Polyfill for browsers with no classList support\n    // Remove in v2\n\n\n    if (!('classList' in document.createElement('_'))) {\n      (function (view) {\n        if (!('Element' in view)) return;\n\n        var classListProp = 'classList',\n            protoProp = 'prototype',\n            elemCtrProto = view.Element[protoProp],\n            objCtr = Object,\n            classListGetter = function classListGetter() {\n          var $elem = $(this);\n          return {\n            add: function add(classes) {\n              classes = Array.prototype.slice.call(arguments).join(' ');\n              return $elem.addClass(classes);\n            },\n            remove: function remove(classes) {\n              classes = Array.prototype.slice.call(arguments).join(' ');\n              return $elem.removeClass(classes);\n            },\n            toggle: function toggle(classes, force) {\n              return $elem.toggleClass(classes, force);\n            },\n            contains: function contains(classes) {\n              return $elem.hasClass(classes);\n            }\n          };\n        };\n\n        if (objCtr.defineProperty) {\n          var classListPropDesc = {\n            get: classListGetter,\n            enumerable: true,\n            configurable: true\n          };\n\n          try {\n            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n          } catch (ex) {\n            // IE 8 doesn't support enumerable:true\n            // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36\n            // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected\n            if (ex.number === undefined || ex.number === -0x7FF5EC54) {\n              classListPropDesc.enumerable = false;\n              objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n            }\n          }\n        } else if (objCtr[protoProp].__defineGetter__) {\n          elemCtrProto.__defineGetter__(classListProp, classListGetter);\n        }\n      })(window);\n    }\n\n    var testElement = document.createElement('_');\n    testElement.classList.add('c1', 'c2');\n\n    if (!testElement.classList.contains('c2')) {\n      var _add = DOMTokenList.prototype.add,\n          _remove = DOMTokenList.prototype.remove;\n\n      DOMTokenList.prototype.add = function () {\n        Array.prototype.forEach.call(arguments, _add.bind(this));\n      };\n\n      DOMTokenList.prototype.remove = function () {\n        Array.prototype.forEach.call(arguments, _remove.bind(this));\n      };\n    }\n\n    testElement.classList.toggle('c3', false); // Polyfill for IE 10 and Firefox <24, where classList.toggle does not\n    // support the second argument.\n\n    if (testElement.classList.contains('c3')) {\n      var _toggle = DOMTokenList.prototype.toggle;\n\n      DOMTokenList.prototype.toggle = function (token, force) {\n        if (1 in arguments && !this.contains(token) === !force) {\n          return force;\n        } else {\n          return _toggle.call(this, token);\n        }\n      };\n    }\n\n    testElement = null; // shallow array comparison\n\n    function isEqual(array1, array2) {\n      return array1.length === array2.length && array1.every(function (element, index) {\n        return element === array2[index];\n      });\n    }\n\n    ; // <editor-fold desc=\"Shims\">\n\n    if (!String.prototype.startsWith) {\n      (function () {\n        'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\n\n        var defineProperty = function () {\n          // IE 8 only supports `Object.defineProperty` on DOM elements\n          try {\n            var object = {};\n            var $defineProperty = Object.defineProperty;\n            var result = $defineProperty(object, object, object) && $defineProperty;\n          } catch (error) {}\n\n          return result;\n        }();\n\n        var toString = {}.toString;\n\n        var startsWith = function startsWith(search) {\n          if (this == null) {\n            throw new TypeError();\n          }\n\n          var string = String(this);\n\n          if (search && toString.call(search) == '[object RegExp]') {\n            throw new TypeError();\n          }\n\n          var stringLength = string.length;\n          var searchString = String(search);\n          var searchLength = searchString.length;\n          var position = arguments.length > 1 ? arguments[1] : undefined; // `ToInteger`\n\n          var pos = position ? Number(position) : 0;\n\n          if (pos != pos) {\n            // better `isNaN`\n            pos = 0;\n          }\n\n          var start = Math.min(Math.max(pos, 0), stringLength); // Avoid the `indexOf` call if no match is possible\n\n          if (searchLength + start > stringLength) {\n            return false;\n          }\n\n          var index = -1;\n\n          while (++index < searchLength) {\n            if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {\n              return false;\n            }\n          }\n\n          return true;\n        };\n\n        if (defineProperty) {\n          defineProperty(String.prototype, 'startsWith', {\n            'value': startsWith,\n            'configurable': true,\n            'writable': true\n          });\n        } else {\n          String.prototype.startsWith = startsWith;\n        }\n      })();\n    }\n\n    if (!Object.keys) {\n      Object.keys = function (o, // object\n      k, // key\n      r // result array\n      ) {\n        // initialize object and result\n        r = []; // iterate over object keys\n\n        for (k in o) {\n          // fill result array with non-prototypical keys\n          r.hasOwnProperty.call(o, k) && r.push(k);\n        } // return result\n\n\n        return r;\n      };\n    }\n\n    if (HTMLSelectElement && !HTMLSelectElement.prototype.hasOwnProperty('selectedOptions')) {\n      Object.defineProperty(HTMLSelectElement.prototype, 'selectedOptions', {\n        get: function get() {\n          return this.querySelectorAll(':checked');\n        }\n      });\n    }\n\n    function getSelectedOptions(select, ignoreDisabled) {\n      var selectedOptions = select.selectedOptions,\n          options = [],\n          opt;\n\n      if (ignoreDisabled) {\n        for (var i = 0, len = selectedOptions.length; i < len; i++) {\n          opt = selectedOptions[i];\n\n          if (!(opt.disabled || opt.parentNode.tagName === 'OPTGROUP' && opt.parentNode.disabled)) {\n            options.push(opt);\n          }\n        }\n\n        return options;\n      }\n\n      return selectedOptions;\n    } // much faster than $.val()\n\n\n    function getSelectValues(select, selectedOptions) {\n      var value = [],\n          options = selectedOptions || select.selectedOptions,\n          opt;\n\n      for (var i = 0, len = options.length; i < len; i++) {\n        opt = options[i];\n\n        if (!(opt.disabled || opt.parentNode.tagName === 'OPTGROUP' && opt.parentNode.disabled)) {\n          value.push(opt.value);\n        }\n      }\n\n      if (!select.multiple) {\n        return !value.length ? null : value[0];\n      }\n\n      return value;\n    } // set data-selected on select element if the value has been programmatically selected\n    // prior to initialization of bootstrap-select\n    // * consider removing or replacing an alternative method *\n\n\n    var valHooks = {\n      useDefault: false,\n      _set: $.valHooks.select.set\n    };\n\n    $.valHooks.select.set = function (elem, value) {\n      if (value && !valHooks.useDefault) $(elem).data('selected', true);\n      return valHooks._set.apply(this, arguments);\n    };\n\n    var changedArguments = null;\n\n    var EventIsSupported = function () {\n      try {\n        new Event('change');\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }();\n\n    $.fn.triggerNative = function (eventName) {\n      var el = this[0],\n          event;\n\n      if (el.dispatchEvent) {\n        // for modern browsers & IE9+\n        if (EventIsSupported) {\n          // For modern browsers\n          event = new Event(eventName, {\n            bubbles: true\n          });\n        } else {\n          // For IE since it doesn't support Event constructor\n          event = document.createEvent('Event');\n          event.initEvent(eventName, true, false);\n        }\n\n        el.dispatchEvent(event);\n      } else if (el.fireEvent) {\n        // for IE8\n        event = document.createEventObject();\n        event.eventType = eventName;\n        el.fireEvent('on' + eventName, event);\n      } else {\n        // fall back to jQuery.trigger\n        this.trigger(eventName);\n      }\n    }; // </editor-fold>\n\n\n    function stringSearch(li, searchString, method, normalize) {\n      var stringTypes = ['display', 'subtext', 'tokens'],\n          searchSuccess = false;\n\n      for (var i = 0; i < stringTypes.length; i++) {\n        var stringType = stringTypes[i],\n            string = li[stringType];\n\n        if (string) {\n          string = string.toString(); // Strip HTML tags. This isn't perfect, but it's much faster than any other method\n\n          if (stringType === 'display') {\n            string = string.replace(/<[^>]+>/g, '');\n          }\n\n          if (normalize) string = normalizeToBase(string);\n          string = string.toUpperCase();\n\n          if (method === 'contains') {\n            searchSuccess = string.indexOf(searchString) >= 0;\n          } else {\n            searchSuccess = string.startsWith(searchString);\n          }\n\n          if (searchSuccess) break;\n        }\n      }\n\n      return searchSuccess;\n    }\n\n    function toInteger(value) {\n      return parseInt(value, 10) || 0;\n    } // Borrowed from Lodash (_.deburr)\n\n    /** Used to map Latin Unicode letters to basic Latin letters. */\n\n\n    var deburredLetters = {\n      // Latin-1 Supplement block.\n      '\\xc0': 'A',\n      '\\xc1': 'A',\n      '\\xc2': 'A',\n      '\\xc3': 'A',\n      '\\xc4': 'A',\n      '\\xc5': 'A',\n      '\\xe0': 'a',\n      '\\xe1': 'a',\n      '\\xe2': 'a',\n      '\\xe3': 'a',\n      '\\xe4': 'a',\n      '\\xe5': 'a',\n      '\\xc7': 'C',\n      '\\xe7': 'c',\n      '\\xd0': 'D',\n      '\\xf0': 'd',\n      '\\xc8': 'E',\n      '\\xc9': 'E',\n      '\\xca': 'E',\n      '\\xcb': 'E',\n      '\\xe8': 'e',\n      '\\xe9': 'e',\n      '\\xea': 'e',\n      '\\xeb': 'e',\n      '\\xcc': 'I',\n      '\\xcd': 'I',\n      '\\xce': 'I',\n      '\\xcf': 'I',\n      '\\xec': 'i',\n      '\\xed': 'i',\n      '\\xee': 'i',\n      '\\xef': 'i',\n      '\\xd1': 'N',\n      '\\xf1': 'n',\n      '\\xd2': 'O',\n      '\\xd3': 'O',\n      '\\xd4': 'O',\n      '\\xd5': 'O',\n      '\\xd6': 'O',\n      '\\xd8': 'O',\n      '\\xf2': 'o',\n      '\\xf3': 'o',\n      '\\xf4': 'o',\n      '\\xf5': 'o',\n      '\\xf6': 'o',\n      '\\xf8': 'o',\n      '\\xd9': 'U',\n      '\\xda': 'U',\n      '\\xdb': 'U',\n      '\\xdc': 'U',\n      '\\xf9': 'u',\n      '\\xfa': 'u',\n      '\\xfb': 'u',\n      '\\xfc': 'u',\n      '\\xdd': 'Y',\n      '\\xfd': 'y',\n      '\\xff': 'y',\n      '\\xc6': 'Ae',\n      '\\xe6': 'ae',\n      '\\xde': 'Th',\n      '\\xfe': 'th',\n      '\\xdf': 'ss',\n      // Latin Extended-A block.\n      \"\\u0100\": 'A',\n      \"\\u0102\": 'A',\n      \"\\u0104\": 'A',\n      \"\\u0101\": 'a',\n      \"\\u0103\": 'a',\n      \"\\u0105\": 'a',\n      \"\\u0106\": 'C',\n      \"\\u0108\": 'C',\n      \"\\u010A\": 'C',\n      \"\\u010C\": 'C',\n      \"\\u0107\": 'c',\n      \"\\u0109\": 'c',\n      \"\\u010B\": 'c',\n      \"\\u010D\": 'c',\n      \"\\u010E\": 'D',\n      \"\\u0110\": 'D',\n      \"\\u010F\": 'd',\n      \"\\u0111\": 'd',\n      \"\\u0112\": 'E',\n      \"\\u0114\": 'E',\n      \"\\u0116\": 'E',\n      \"\\u0118\": 'E',\n      \"\\u011A\": 'E',\n      \"\\u0113\": 'e',\n      \"\\u0115\": 'e',\n      \"\\u0117\": 'e',\n      \"\\u0119\": 'e',\n      \"\\u011B\": 'e',\n      \"\\u011C\": 'G',\n      \"\\u011E\": 'G',\n      \"\\u0120\": 'G',\n      \"\\u0122\": 'G',\n      \"\\u011D\": 'g',\n      \"\\u011F\": 'g',\n      \"\\u0121\": 'g',\n      \"\\u0123\": 'g',\n      \"\\u0124\": 'H',\n      \"\\u0126\": 'H',\n      \"\\u0125\": 'h',\n      \"\\u0127\": 'h',\n      \"\\u0128\": 'I',\n      \"\\u012A\": 'I',\n      \"\\u012C\": 'I',\n      \"\\u012E\": 'I',\n      \"\\u0130\": 'I',\n      \"\\u0129\": 'i',\n      \"\\u012B\": 'i',\n      \"\\u012D\": 'i',\n      \"\\u012F\": 'i',\n      \"\\u0131\": 'i',\n      \"\\u0134\": 'J',\n      \"\\u0135\": 'j',\n      \"\\u0136\": 'K',\n      \"\\u0137\": 'k',\n      \"\\u0138\": 'k',\n      \"\\u0139\": 'L',\n      \"\\u013B\": 'L',\n      \"\\u013D\": 'L',\n      \"\\u013F\": 'L',\n      \"\\u0141\": 'L',\n      \"\\u013A\": 'l',\n      \"\\u013C\": 'l',\n      \"\\u013E\": 'l',\n      \"\\u0140\": 'l',\n      \"\\u0142\": 'l',\n      \"\\u0143\": 'N',\n      \"\\u0145\": 'N',\n      \"\\u0147\": 'N',\n      \"\\u014A\": 'N',\n      \"\\u0144\": 'n',\n      \"\\u0146\": 'n',\n      \"\\u0148\": 'n',\n      \"\\u014B\": 'n',\n      \"\\u014C\": 'O',\n      \"\\u014E\": 'O',\n      \"\\u0150\": 'O',\n      \"\\u014D\": 'o',\n      \"\\u014F\": 'o',\n      \"\\u0151\": 'o',\n      \"\\u0154\": 'R',\n      \"\\u0156\": 'R',\n      \"\\u0158\": 'R',\n      \"\\u0155\": 'r',\n      \"\\u0157\": 'r',\n      \"\\u0159\": 'r',\n      \"\\u015A\": 'S',\n      \"\\u015C\": 'S',\n      \"\\u015E\": 'S',\n      \"\\u0160\": 'S',\n      \"\\u015B\": 's',\n      \"\\u015D\": 's',\n      \"\\u015F\": 's',\n      \"\\u0161\": 's',\n      \"\\u0162\": 'T',\n      \"\\u0164\": 'T',\n      \"\\u0166\": 'T',\n      \"\\u0163\": 't',\n      \"\\u0165\": 't',\n      \"\\u0167\": 't',\n      \"\\u0168\": 'U',\n      \"\\u016A\": 'U',\n      \"\\u016C\": 'U',\n      \"\\u016E\": 'U',\n      \"\\u0170\": 'U',\n      \"\\u0172\": 'U',\n      \"\\u0169\": 'u',\n      \"\\u016B\": 'u',\n      \"\\u016D\": 'u',\n      \"\\u016F\": 'u',\n      \"\\u0171\": 'u',\n      \"\\u0173\": 'u',\n      \"\\u0174\": 'W',\n      \"\\u0175\": 'w',\n      \"\\u0176\": 'Y',\n      \"\\u0177\": 'y',\n      \"\\u0178\": 'Y',\n      \"\\u0179\": 'Z',\n      \"\\u017B\": 'Z',\n      \"\\u017D\": 'Z',\n      \"\\u017A\": 'z',\n      \"\\u017C\": 'z',\n      \"\\u017E\": 'z',\n      \"\\u0132\": 'IJ',\n      \"\\u0133\": 'ij',\n      \"\\u0152\": 'Oe',\n      \"\\u0153\": 'oe',\n      \"\\u0149\": \"'n\",\n      \"\\u017F\": 's'\n    };\n    /** Used to match Latin Unicode letters (excluding mathematical operators). */\n\n    var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n    /** Used to compose unicode character classes. */\n\n    var rsComboMarksRange = \"\\\\u0300-\\\\u036f\",\n        reComboHalfMarksRange = \"\\\\ufe20-\\\\ufe2f\",\n        rsComboSymbolsRange = \"\\\\u20d0-\\\\u20ff\",\n        rsComboMarksExtendedRange = \"\\\\u1ab0-\\\\u1aff\",\n        rsComboMarksSupplementRange = \"\\\\u1dc0-\\\\u1dff\",\n        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\n    /** Used to compose unicode capture groups. */\n\n    var rsCombo = '[' + rsComboRange + ']';\n    /**\r\n     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\r\n     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\r\n     */\n\n    var reComboMark = RegExp(rsCombo, 'g');\n\n    function deburrLetter(key) {\n      return deburredLetters[key];\n    }\n\n    ;\n\n    function normalizeToBase(string) {\n      string = string.toString();\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    } // List of HTML entities for escaping.\n\n\n    var escapeMap = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '`': '&#x60;'\n    }; // Functions for escaping and unescaping strings to/from HTML interpolation.\n\n    var createEscaper = function createEscaper(map) {\n      var escaper = function escaper(match) {\n        return map[match];\n      }; // Regexes for identifying a key that needs to be escaped.\n\n\n      var source = '(?:' + Object.keys(map).join('|') + ')';\n      var testRegexp = RegExp(source);\n      var replaceRegexp = RegExp(source, 'g');\n      return function (string) {\n        string = string == null ? '' : '' + string;\n        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n      };\n    };\n\n    var htmlEscape = createEscaper(escapeMap);\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * Constants\r\n     * ------------------------------------------------------------------------\r\n     */\n\n    var keyCodeMap = {\n      32: ' ',\n      48: '0',\n      49: '1',\n      50: '2',\n      51: '3',\n      52: '4',\n      53: '5',\n      54: '6',\n      55: '7',\n      56: '8',\n      57: '9',\n      59: ';',\n      65: 'A',\n      66: 'B',\n      67: 'C',\n      68: 'D',\n      69: 'E',\n      70: 'F',\n      71: 'G',\n      72: 'H',\n      73: 'I',\n      74: 'J',\n      75: 'K',\n      76: 'L',\n      77: 'M',\n      78: 'N',\n      79: 'O',\n      80: 'P',\n      81: 'Q',\n      82: 'R',\n      83: 'S',\n      84: 'T',\n      85: 'U',\n      86: 'V',\n      87: 'W',\n      88: 'X',\n      89: 'Y',\n      90: 'Z',\n      96: '0',\n      97: '1',\n      98: '2',\n      99: '3',\n      100: '4',\n      101: '5',\n      102: '6',\n      103: '7',\n      104: '8',\n      105: '9'\n    };\n    var keyCodes = {\n      ESCAPE: 27,\n      // KeyboardEvent.which value for Escape (Esc) key\n      ENTER: 13,\n      // KeyboardEvent.which value for Enter key\n      SPACE: 32,\n      // KeyboardEvent.which value for space key\n      TAB: 9,\n      // KeyboardEvent.which value for tab key\n      ARROW_UP: 38,\n      // KeyboardEvent.which value for up arrow key\n      ARROW_DOWN: 40 // KeyboardEvent.which value for down arrow key\n\n    };\n    var version = {\n      success: false,\n      major: '3'\n    };\n\n    try {\n      version.full = ($.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.');\n      version.major = version.full[0];\n      version.success = true;\n    } catch (err) {// do nothing\n    }\n\n    var selectId = 0;\n    var EVENT_KEY = '.bs.select';\n    var classNames = {\n      DISABLED: 'disabled',\n      DIVIDER: 'divider',\n      SHOW: 'open',\n      DROPUP: 'dropup',\n      MENU: 'dropdown-menu',\n      MENURIGHT: 'dropdown-menu-right',\n      MENULEFT: 'dropdown-menu-left',\n      // to-do: replace with more advanced template/customization options\n      BUTTONCLASS: 'btn-default',\n      POPOVERHEADER: 'popover-title',\n      ICONBASE: 'glyphicon',\n      TICKICON: 'glyphicon-ok'\n    };\n    var Selector = {\n      MENU: '.' + classNames.MENU\n    };\n    var elementTemplates = {\n      div: document.createElement('div'),\n      span: document.createElement('span'),\n      i: document.createElement('i'),\n      subtext: document.createElement('small'),\n      a: document.createElement('a'),\n      li: document.createElement('li'),\n      whitespace: document.createTextNode(\"\\xA0\"),\n      fragment: document.createDocumentFragment()\n    };\n    elementTemplates.noResults = elementTemplates.li.cloneNode(false);\n    elementTemplates.noResults.className = 'no-results';\n    elementTemplates.a.setAttribute('role', 'option');\n    elementTemplates.a.className = 'dropdown-item';\n    elementTemplates.subtext.className = 'text-muted';\n    elementTemplates.text = elementTemplates.span.cloneNode(false);\n    elementTemplates.text.className = 'text';\n    elementTemplates.checkMark = elementTemplates.span.cloneNode(false);\n    var REGEXP_ARROW = new RegExp(keyCodes.ARROW_UP + '|' + keyCodes.ARROW_DOWN);\n    var REGEXP_TAB_OR_ESCAPE = new RegExp('^' + keyCodes.TAB + '$|' + keyCodes.ESCAPE);\n    var generateOption = {\n      li: function li(content, classes, optgroup) {\n        var li = elementTemplates.li.cloneNode(false);\n\n        if (content) {\n          if (content.nodeType === 1 || content.nodeType === 11) {\n            li.appendChild(content);\n          } else {\n            li.innerHTML = content;\n          }\n        }\n\n        if (typeof classes !== 'undefined' && classes !== '') li.className = classes;\n        if (typeof optgroup !== 'undefined' && optgroup !== null) li.classList.add('optgroup-' + optgroup);\n        return li;\n      },\n      a: function a(text, classes, inline) {\n        var a = elementTemplates.a.cloneNode(true);\n\n        if (text) {\n          if (text.nodeType === 11) {\n            a.appendChild(text);\n          } else {\n            a.insertAdjacentHTML('beforeend', text);\n          }\n        }\n\n        if (typeof classes !== 'undefined' && classes !== '') a.classList.add.apply(a.classList, classes.split(/\\s+/));\n        if (inline) a.setAttribute('style', inline);\n        return a;\n      },\n      text: function text(options, useFragment) {\n        var textElement = elementTemplates.text.cloneNode(false),\n            subtextElement,\n            iconElement;\n\n        if (options.content) {\n          textElement.innerHTML = options.content;\n        } else {\n          textElement.textContent = options.text;\n\n          if (options.icon) {\n            var whitespace = elementTemplates.whitespace.cloneNode(false); // need to use <i> for icons in the button to prevent a breaking change\n            // note: switch to span in next major release\n\n            iconElement = (useFragment === true ? elementTemplates.i : elementTemplates.span).cloneNode(false);\n            iconElement.className = this.options.iconBase + ' ' + options.icon;\n            elementTemplates.fragment.appendChild(iconElement);\n            elementTemplates.fragment.appendChild(whitespace);\n          }\n\n          if (options.subtext) {\n            subtextElement = elementTemplates.subtext.cloneNode(false);\n            subtextElement.textContent = options.subtext;\n            textElement.appendChild(subtextElement);\n          }\n        }\n\n        if (useFragment === true) {\n          while (textElement.childNodes.length > 0) {\n            elementTemplates.fragment.appendChild(textElement.childNodes[0]);\n          }\n        } else {\n          elementTemplates.fragment.appendChild(textElement);\n        }\n\n        return elementTemplates.fragment;\n      },\n      label: function label(options) {\n        var textElement = elementTemplates.text.cloneNode(false),\n            subtextElement,\n            iconElement;\n        textElement.innerHTML = options.display;\n\n        if (options.icon) {\n          var whitespace = elementTemplates.whitespace.cloneNode(false);\n          iconElement = elementTemplates.span.cloneNode(false);\n          iconElement.className = this.options.iconBase + ' ' + options.icon;\n          elementTemplates.fragment.appendChild(iconElement);\n          elementTemplates.fragment.appendChild(whitespace);\n        }\n\n        if (options.subtext) {\n          subtextElement = elementTemplates.subtext.cloneNode(false);\n          subtextElement.textContent = options.subtext;\n          textElement.appendChild(subtextElement);\n        }\n\n        elementTemplates.fragment.appendChild(textElement);\n        return elementTemplates.fragment;\n      }\n    };\n\n    function showNoResults(searchMatch, searchValue) {\n      if (!searchMatch.length) {\n        elementTemplates.noResults.innerHTML = this.options.noneResultsText.replace('{0}', '\"' + htmlEscape(searchValue) + '\"');\n        this.$menuInner[0].firstChild.appendChild(elementTemplates.noResults);\n      }\n    }\n\n    var Selectpicker = function Selectpicker(element, options) {\n      var that = this; // bootstrap-select has been initialized - revert valHooks.select.set back to its original function\n\n      if (!valHooks.useDefault) {\n        $.valHooks.select.set = valHooks._set;\n        valHooks.useDefault = true;\n      }\n\n      this.$element = $(element);\n      this.$newElement = null;\n      this.$button = null;\n      this.$menu = null;\n      this.options = options;\n      this.selectpicker = {\n        main: {},\n        search: {},\n        current: {},\n        // current changes if a search is in progress\n        view: {},\n        isSearching: false,\n        keydown: {\n          keyHistory: '',\n          resetKeyHistory: {\n            start: function start() {\n              return setTimeout(function () {\n                that.selectpicker.keydown.keyHistory = '';\n              }, 800);\n            }\n          }\n        }\n      };\n      this.sizeInfo = {}; // If we have no title yet, try to pull it from the html title attribute (jQuery doesnt' pick it up as it's not a\n      // data-attribute)\n\n      if (this.options.title === null) {\n        this.options.title = this.$element.attr('title');\n      } // Format window padding\n\n\n      var winPad = this.options.windowPadding;\n\n      if (typeof winPad === 'number') {\n        this.options.windowPadding = [winPad, winPad, winPad, winPad];\n      } // Expose public methods\n\n\n      this.val = Selectpicker.prototype.val;\n      this.render = Selectpicker.prototype.render;\n      this.refresh = Selectpicker.prototype.refresh;\n      this.setStyle = Selectpicker.prototype.setStyle;\n      this.selectAll = Selectpicker.prototype.selectAll;\n      this.deselectAll = Selectpicker.prototype.deselectAll;\n      this.destroy = Selectpicker.prototype.destroy;\n      this.remove = Selectpicker.prototype.remove;\n      this.show = Selectpicker.prototype.show;\n      this.hide = Selectpicker.prototype.hide;\n      this.init();\n    };\n\n    Selectpicker.VERSION = '1.13.18'; // part of this is duplicated in i18n/defaults-en_US.js. Make sure to update both.\n\n    Selectpicker.DEFAULTS = {\n      noneSelectedText: 'Nothing selected',\n      noneResultsText: 'No results matched {0}',\n      countSelectedText: function countSelectedText(numSelected, numTotal) {\n        return numSelected == 1 ? '{0} item selected' : '{0} items selected';\n      },\n      maxOptionsText: function maxOptionsText(numAll, numGroup) {\n        return [numAll == 1 ? 'Limit reached ({n} item max)' : 'Limit reached ({n} items max)', numGroup == 1 ? 'Group limit reached ({n} item max)' : 'Group limit reached ({n} items max)'];\n      },\n      selectAllText: 'Select All',\n      deselectAllText: 'Deselect All',\n      doneButton: false,\n      doneButtonText: 'Close',\n      multipleSeparator: ', ',\n      styleBase: 'btn',\n      style: classNames.BUTTONCLASS,\n      size: 'auto',\n      title: null,\n      selectedTextFormat: 'values',\n      width: false,\n      container: false,\n      hideDisabled: false,\n      showSubtext: false,\n      showIcon: true,\n      showContent: true,\n      dropupAuto: true,\n      header: false,\n      liveSearch: false,\n      liveSearchPlaceholder: null,\n      liveSearchNormalize: false,\n      liveSearchStyle: 'contains',\n      actionsBox: false,\n      iconBase: classNames.ICONBASE,\n      tickIcon: classNames.TICKICON,\n      showTick: false,\n      template: {\n        caret: '<span class=\"caret\"></span>'\n      },\n      maxOptions: false,\n      mobile: false,\n      selectOnTab: false,\n      dropdownAlignRight: false,\n      windowPadding: 0,\n      virtualScroll: 600,\n      display: false,\n      sanitize: true,\n      sanitizeFn: null,\n      whiteList: DefaultWhitelist\n    };\n    Selectpicker.prototype = {\n      constructor: Selectpicker,\n      init: function init() {\n        var that = this,\n            id = this.$element.attr('id'),\n            element = this.$element[0],\n            form = element.form;\n        selectId++;\n        this.selectId = 'bs-select-' + selectId;\n        element.classList.add('bs-select-hidden');\n        this.multiple = this.$element.prop('multiple');\n        this.autofocus = this.$element.prop('autofocus');\n\n        if (element.classList.contains('show-tick')) {\n          this.options.showTick = true;\n        }\n\n        this.$newElement = this.createDropdown();\n        this.buildData();\n        this.$element.after(this.$newElement).prependTo(this.$newElement); // ensure select is associated with form element if it got unlinked after moving it inside newElement\n\n        if (form && element.form === null) {\n          if (!form.id) form.id = 'form-' + this.selectId;\n          element.setAttribute('form', form.id);\n        }\n\n        this.$button = this.$newElement.children('button');\n        this.$menu = this.$newElement.children(Selector.MENU);\n        this.$menuInner = this.$menu.children('.inner');\n        this.$searchbox = this.$menu.find('input');\n        element.classList.remove('bs-select-hidden');\n        if (this.options.dropdownAlignRight === true) this.$menu[0].classList.add(classNames.MENURIGHT);\n\n        if (typeof id !== 'undefined') {\n          this.$button.attr('data-id', id);\n        }\n\n        this.checkDisabled();\n        this.clickListener();\n\n        if (this.options.liveSearch) {\n          this.liveSearchListener();\n          this.focusedParent = this.$searchbox[0];\n        } else {\n          this.focusedParent = this.$menuInner[0];\n        }\n\n        this.setStyle();\n        this.render();\n        this.setWidth();\n\n        if (this.options.container) {\n          this.selectPosition();\n        } else {\n          this.$element.on('hide' + EVENT_KEY, function () {\n            if (that.isVirtual()) {\n              // empty menu on close\n              var menuInner = that.$menuInner[0],\n                  emptyMenu = menuInner.firstChild.cloneNode(false); // replace the existing UL with an empty one - this is faster than $.empty() or innerHTML = ''\n\n              menuInner.replaceChild(emptyMenu, menuInner.firstChild);\n              menuInner.scrollTop = 0;\n            }\n          });\n        }\n\n        this.$menu.data('this', this);\n        this.$newElement.data('this', this);\n        if (this.options.mobile) this.mobile();\n        this.$newElement.on({\n          'hide.bs.dropdown': function hideBsDropdown(e) {\n            that.$element.trigger('hide' + EVENT_KEY, e);\n          },\n          'hidden.bs.dropdown': function hiddenBsDropdown(e) {\n            that.$element.trigger('hidden' + EVENT_KEY, e);\n          },\n          'show.bs.dropdown': function showBsDropdown(e) {\n            that.$element.trigger('show' + EVENT_KEY, e);\n          },\n          'shown.bs.dropdown': function shownBsDropdown(e) {\n            that.$element.trigger('shown' + EVENT_KEY, e);\n          }\n        });\n\n        if (element.hasAttribute('required')) {\n          this.$element.on('invalid' + EVENT_KEY, function () {\n            that.$button[0].classList.add('bs-invalid');\n            that.$element.on('shown' + EVENT_KEY + '.invalid', function () {\n              that.$element.val(that.$element.val()) // set the value to hide the validation message in Chrome when menu is opened\n              .off('shown' + EVENT_KEY + '.invalid');\n            }).on('rendered' + EVENT_KEY, function () {\n              // if select is no longer invalid, remove the bs-invalid class\n              if (this.validity.valid) that.$button[0].classList.remove('bs-invalid');\n              that.$element.off('rendered' + EVENT_KEY);\n            });\n            that.$button.on('blur' + EVENT_KEY, function () {\n              that.$element.trigger('focus').trigger('blur');\n              that.$button.off('blur' + EVENT_KEY);\n            });\n          });\n        }\n\n        setTimeout(function () {\n          that.buildList();\n          that.$element.trigger('loaded' + EVENT_KEY);\n        });\n      },\n      createDropdown: function createDropdown() {\n        // Options\n        // If we are multiple or showTick option is set, then add the show-tick class\n        var showTick = this.multiple || this.options.showTick ? ' show-tick' : '',\n            multiselectable = this.multiple ? ' aria-multiselectable=\"true\"' : '',\n            inputGroup = '',\n            autofocus = this.autofocus ? ' autofocus' : '';\n\n        if (version.major < 4 && this.$element.parent().hasClass('input-group')) {\n          inputGroup = ' input-group-btn';\n        } // Elements\n\n\n        var drop,\n            header = '',\n            searchbox = '',\n            actionsbox = '',\n            donebutton = '';\n\n        if (this.options.header) {\n          header = '<div class=\"' + classNames.POPOVERHEADER + '\">' + '<button type=\"button\" class=\"close\" aria-hidden=\"true\">&times;</button>' + this.options.header + '</div>';\n        }\n\n        if (this.options.liveSearch) {\n          searchbox = '<div class=\"bs-searchbox\">' + '<input type=\"search\" class=\"form-control\" autocomplete=\"off\"' + (this.options.liveSearchPlaceholder === null ? '' : ' placeholder=\"' + htmlEscape(this.options.liveSearchPlaceholder) + '\"') + ' role=\"combobox\" aria-label=\"Search\" aria-controls=\"' + this.selectId + '\" aria-autocomplete=\"list\">' + '</div>';\n        }\n\n        if (this.multiple && this.options.actionsBox) {\n          actionsbox = '<div class=\"bs-actionsbox\">' + '<div class=\"btn-group btn-group-sm btn-block\">' + '<button type=\"button\" class=\"actions-btn bs-select-all btn ' + classNames.BUTTONCLASS + '\">' + this.options.selectAllText + '</button>' + '<button type=\"button\" class=\"actions-btn bs-deselect-all btn ' + classNames.BUTTONCLASS + '\">' + this.options.deselectAllText + '</button>' + '</div>' + '</div>';\n        }\n\n        if (this.multiple && this.options.doneButton) {\n          donebutton = '<div class=\"bs-donebutton\">' + '<div class=\"btn-group btn-block\">' + '<button type=\"button\" class=\"btn btn-sm ' + classNames.BUTTONCLASS + '\">' + this.options.doneButtonText + '</button>' + '</div>' + '</div>';\n        }\n\n        drop = '<div class=\"dropdown bootstrap-select' + showTick + inputGroup + '\">' + '<button type=\"button\" tabindex=\"-1\" class=\"' + this.options.styleBase + ' dropdown-toggle\" ' + (this.options.display === 'static' ? 'data-display=\"static\"' : '') + 'data-toggle=\"dropdown\"' + autofocus + ' role=\"combobox\" aria-owns=\"' + this.selectId + '\" aria-haspopup=\"listbox\" aria-expanded=\"false\">' + '<div class=\"filter-option\">' + '<div class=\"filter-option-inner\">' + '<div class=\"filter-option-inner-inner\"></div>' + '</div> ' + '</div>' + (version.major === '4' ? '' : '<span class=\"bs-caret\">' + this.options.template.caret + '</span>') + '</button>' + '<div class=\"' + classNames.MENU + ' ' + (version.major === '4' ? '' : classNames.SHOW) + '\">' + header + searchbox + actionsbox + '<div class=\"inner ' + classNames.SHOW + '\" role=\"listbox\" id=\"' + this.selectId + '\" tabindex=\"-1\" ' + multiselectable + '>' + '<ul class=\"' + classNames.MENU + ' inner ' + (version.major === '4' ? classNames.SHOW : '') + '\" role=\"presentation\">' + '</ul>' + '</div>' + donebutton + '</div>' + '</div>';\n        return $(drop);\n      },\n      setPositionData: function setPositionData() {\n        this.selectpicker.view.canHighlight = [];\n        this.selectpicker.view.size = 0;\n        this.selectpicker.view.firstHighlightIndex = false;\n\n        for (var i = 0; i < this.selectpicker.current.data.length; i++) {\n          var li = this.selectpicker.current.data[i],\n              canHighlight = true;\n\n          if (li.type === 'divider') {\n            canHighlight = false;\n            li.height = this.sizeInfo.dividerHeight;\n          } else if (li.type === 'optgroup-label') {\n            canHighlight = false;\n            li.height = this.sizeInfo.dropdownHeaderHeight;\n          } else {\n            li.height = this.sizeInfo.liHeight;\n          }\n\n          if (li.disabled) canHighlight = false;\n          this.selectpicker.view.canHighlight.push(canHighlight);\n\n          if (canHighlight) {\n            this.selectpicker.view.size++;\n            li.posinset = this.selectpicker.view.size;\n            if (this.selectpicker.view.firstHighlightIndex === false) this.selectpicker.view.firstHighlightIndex = i;\n          }\n\n          li.position = (i === 0 ? 0 : this.selectpicker.current.data[i - 1].position) + li.height;\n        }\n      },\n      isVirtual: function isVirtual() {\n        return this.options.virtualScroll !== false && this.selectpicker.main.elements.length >= this.options.virtualScroll || this.options.virtualScroll === true;\n      },\n      createView: function createView(isSearching, setSize, refresh) {\n        var that = this,\n            scrollTop = 0,\n            active = [],\n            selected,\n            prevActive;\n        this.selectpicker.isSearching = isSearching;\n        this.selectpicker.current = isSearching ? this.selectpicker.search : this.selectpicker.main;\n        this.setPositionData();\n\n        if (setSize) {\n          if (refresh) {\n            scrollTop = this.$menuInner[0].scrollTop;\n          } else if (!that.multiple) {\n            var element = that.$element[0],\n                selectedIndex = (element.options[element.selectedIndex] || {}).liIndex;\n\n            if (typeof selectedIndex === 'number' && that.options.size !== false) {\n              var selectedData = that.selectpicker.main.data[selectedIndex],\n                  position = selectedData && selectedData.position;\n\n              if (position) {\n                scrollTop = position - (that.sizeInfo.menuInnerHeight + that.sizeInfo.liHeight) / 2;\n              }\n            }\n          }\n        }\n\n        scroll(scrollTop, true);\n        this.$menuInner.off('scroll.createView').on('scroll.createView', function (e, updateValue) {\n          if (!that.noScroll) scroll(this.scrollTop, updateValue);\n          that.noScroll = false;\n        });\n\n        function scroll(scrollTop, init) {\n          var size = that.selectpicker.current.elements.length,\n              chunks = [],\n              chunkSize,\n              chunkCount,\n              firstChunk,\n              lastChunk,\n              currentChunk,\n              prevPositions,\n              positionIsDifferent,\n              previousElements,\n              menuIsDifferent = true,\n              isVirtual = that.isVirtual();\n          that.selectpicker.view.scrollTop = scrollTop;\n          chunkSize = Math.ceil(that.sizeInfo.menuInnerHeight / that.sizeInfo.liHeight * 1.5); // number of options in a chunk\n\n          chunkCount = Math.round(size / chunkSize) || 1; // number of chunks\n\n          for (var i = 0; i < chunkCount; i++) {\n            var endOfChunk = (i + 1) * chunkSize;\n\n            if (i === chunkCount - 1) {\n              endOfChunk = size;\n            }\n\n            chunks[i] = [i * chunkSize + (!i ? 0 : 1), endOfChunk];\n            if (!size) break;\n\n            if (currentChunk === undefined && scrollTop - 1 <= that.selectpicker.current.data[endOfChunk - 1].position - that.sizeInfo.menuInnerHeight) {\n              currentChunk = i;\n            }\n          }\n\n          if (currentChunk === undefined) currentChunk = 0;\n          prevPositions = [that.selectpicker.view.position0, that.selectpicker.view.position1]; // always display previous, current, and next chunks\n\n          firstChunk = Math.max(0, currentChunk - 1);\n          lastChunk = Math.min(chunkCount - 1, currentChunk + 1);\n          that.selectpicker.view.position0 = isVirtual === false ? 0 : Math.max(0, chunks[firstChunk][0]) || 0;\n          that.selectpicker.view.position1 = isVirtual === false ? size : Math.min(size, chunks[lastChunk][1]) || 0;\n          positionIsDifferent = prevPositions[0] !== that.selectpicker.view.position0 || prevPositions[1] !== that.selectpicker.view.position1;\n\n          if (that.activeIndex !== undefined) {\n            prevActive = that.selectpicker.main.elements[that.prevActiveIndex];\n            active = that.selectpicker.main.elements[that.activeIndex];\n            selected = that.selectpicker.main.elements[that.selectedIndex];\n\n            if (init) {\n              if (that.activeIndex !== that.selectedIndex) {\n                that.defocusItem(active);\n              }\n\n              that.activeIndex = undefined;\n            }\n\n            if (that.activeIndex && that.activeIndex !== that.selectedIndex) {\n              that.defocusItem(selected);\n            }\n          }\n\n          if (that.prevActiveIndex !== undefined && that.prevActiveIndex !== that.activeIndex && that.prevActiveIndex !== that.selectedIndex) {\n            that.defocusItem(prevActive);\n          }\n\n          if (init || positionIsDifferent) {\n            previousElements = that.selectpicker.view.visibleElements ? that.selectpicker.view.visibleElements.slice() : [];\n\n            if (isVirtual === false) {\n              that.selectpicker.view.visibleElements = that.selectpicker.current.elements;\n            } else {\n              that.selectpicker.view.visibleElements = that.selectpicker.current.elements.slice(that.selectpicker.view.position0, that.selectpicker.view.position1);\n            }\n\n            that.setOptionStatus(); // if searching, check to make sure the list has actually been updated before updating DOM\n            // this prevents unnecessary repaints\n\n            if (isSearching || isVirtual === false && init) menuIsDifferent = !isEqual(previousElements, that.selectpicker.view.visibleElements); // if virtual scroll is disabled and not searching,\n            // menu should never need to be updated more than once\n\n            if ((init || isVirtual === true) && menuIsDifferent) {\n              var menuInner = that.$menuInner[0],\n                  menuFragment = document.createDocumentFragment(),\n                  emptyMenu = menuInner.firstChild.cloneNode(false),\n                  marginTop,\n                  marginBottom,\n                  elements = that.selectpicker.view.visibleElements,\n                  toSanitize = []; // replace the existing UL with an empty one - this is faster than $.empty()\n\n              menuInner.replaceChild(emptyMenu, menuInner.firstChild);\n\n              for (var i = 0, visibleElementsLen = elements.length; i < visibleElementsLen; i++) {\n                var element = elements[i],\n                    elText,\n                    elementData;\n\n                if (that.options.sanitize) {\n                  elText = element.lastChild;\n\n                  if (elText) {\n                    elementData = that.selectpicker.current.data[i + that.selectpicker.view.position0];\n\n                    if (elementData && elementData.content && !elementData.sanitized) {\n                      toSanitize.push(elText);\n                      elementData.sanitized = true;\n                    }\n                  }\n                }\n\n                menuFragment.appendChild(element);\n              }\n\n              if (that.options.sanitize && toSanitize.length) {\n                sanitizeHtml(toSanitize, that.options.whiteList, that.options.sanitizeFn);\n              }\n\n              if (isVirtual === true) {\n                marginTop = that.selectpicker.view.position0 === 0 ? 0 : that.selectpicker.current.data[that.selectpicker.view.position0 - 1].position;\n                marginBottom = that.selectpicker.view.position1 > size - 1 ? 0 : that.selectpicker.current.data[size - 1].position - that.selectpicker.current.data[that.selectpicker.view.position1 - 1].position;\n                menuInner.firstChild.style.marginTop = marginTop + 'px';\n                menuInner.firstChild.style.marginBottom = marginBottom + 'px';\n              } else {\n                menuInner.firstChild.style.marginTop = 0;\n                menuInner.firstChild.style.marginBottom = 0;\n              }\n\n              menuInner.firstChild.appendChild(menuFragment); // if an option is encountered that is wider than the current menu width, update the menu width accordingly\n              // switch to ResizeObserver with increased browser support\n\n              if (isVirtual === true && that.sizeInfo.hasScrollBar) {\n                var menuInnerInnerWidth = menuInner.firstChild.offsetWidth;\n\n                if (init && menuInnerInnerWidth < that.sizeInfo.menuInnerInnerWidth && that.sizeInfo.totalMenuWidth > that.sizeInfo.selectWidth) {\n                  menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';\n                } else if (menuInnerInnerWidth > that.sizeInfo.menuInnerInnerWidth) {\n                  // set to 0 to get actual width of menu\n                  that.$menu[0].style.minWidth = 0;\n                  var actualMenuWidth = menuInner.firstChild.offsetWidth;\n\n                  if (actualMenuWidth > that.sizeInfo.menuInnerInnerWidth) {\n                    that.sizeInfo.menuInnerInnerWidth = actualMenuWidth;\n                    menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';\n                  } // reset to default CSS styling\n\n\n                  that.$menu[0].style.minWidth = '';\n                }\n              }\n            }\n          }\n\n          that.prevActiveIndex = that.activeIndex;\n\n          if (!that.options.liveSearch) {\n            that.$menuInner.trigger('focus');\n          } else if (isSearching && init) {\n            var index = 0,\n                newActive;\n\n            if (!that.selectpicker.view.canHighlight[index]) {\n              index = 1 + that.selectpicker.view.canHighlight.slice(1).indexOf(true);\n            }\n\n            newActive = that.selectpicker.view.visibleElements[index];\n            that.defocusItem(that.selectpicker.view.currentActive);\n            that.activeIndex = (that.selectpicker.current.data[index] || {}).index;\n            that.focusItem(newActive);\n          }\n        }\n\n        $(window).off('resize' + EVENT_KEY + '.' + this.selectId + '.createView').on('resize' + EVENT_KEY + '.' + this.selectId + '.createView', function () {\n          var isActive = that.$newElement.hasClass(classNames.SHOW);\n          if (isActive) scroll(that.$menuInner[0].scrollTop);\n        });\n      },\n      focusItem: function focusItem(li, liData, noStyle) {\n        if (li) {\n          liData = liData || this.selectpicker.main.data[this.activeIndex];\n          var a = li.firstChild;\n\n          if (a) {\n            a.setAttribute('aria-setsize', this.selectpicker.view.size);\n            a.setAttribute('aria-posinset', liData.posinset);\n\n            if (noStyle !== true) {\n              this.focusedParent.setAttribute('aria-activedescendant', a.id);\n              li.classList.add('active');\n              a.classList.add('active');\n            }\n          }\n        }\n      },\n      defocusItem: function defocusItem(li) {\n        if (li) {\n          li.classList.remove('active');\n          if (li.firstChild) li.firstChild.classList.remove('active');\n        }\n      },\n      setPlaceholder: function setPlaceholder() {\n        var that = this,\n            updateIndex = false;\n\n        if (this.options.title && !this.multiple) {\n          if (!this.selectpicker.view.titleOption) this.selectpicker.view.titleOption = document.createElement('option'); // this option doesn't create a new <li> element, but does add a new option at the start,\n          // so startIndex should increase to prevent having to check every option for the bs-title-option class\n\n          updateIndex = true;\n          var element = this.$element[0],\n              selectTitleOption = false,\n              titleNotAppended = !this.selectpicker.view.titleOption.parentNode,\n              selectedIndex = element.selectedIndex,\n              selectedOption = element.options[selectedIndex],\n              navigation = window.performance && window.performance.getEntriesByType('navigation'),\n              // Safari doesn't support getEntriesByType('navigation') - fall back to performance.navigation\n          isNotBackForward = navigation && navigation.length ? navigation[0].type !== 'back_forward' : window.performance.navigation.type !== 2;\n\n          if (titleNotAppended) {\n            // Use native JS to prepend option (faster)\n            this.selectpicker.view.titleOption.className = 'bs-title-option';\n            this.selectpicker.view.titleOption.value = ''; // Check if selected or data-selected attribute is already set on an option. If not, select the titleOption option.\n            // the selected item may have been changed by user or programmatically before the bootstrap select plugin runs,\n            // if so, the select will have the data-selected attribute\n\n            selectTitleOption = !selectedOption || selectedIndex === 0 && selectedOption.defaultSelected === false && this.$element.data('selected') === undefined;\n          }\n\n          if (titleNotAppended || this.selectpicker.view.titleOption.index !== 0) {\n            element.insertBefore(this.selectpicker.view.titleOption, element.firstChild);\n          } // Set selected *after* appending to select,\n          // otherwise the option doesn't get selected in IE\n          // set using selectedIndex, as setting the selected attr to true here doesn't work in IE11\n\n\n          if (selectTitleOption && isNotBackForward) {\n            element.selectedIndex = 0;\n          } else if (document.readyState !== 'complete') {\n            // if navigation type is back_forward, there's a chance the select will have its value set by BFCache\n            // wait for that value to be set, then run render again\n            window.addEventListener('pageshow', function () {\n              if (that.selectpicker.view.displayedValue !== element.value) that.render();\n            });\n          }\n        }\n\n        return updateIndex;\n      },\n      buildData: function buildData() {\n        var optionSelector = ':not([hidden]):not([data-hidden=\"true\"])',\n            mainData = [],\n            optID = 0,\n            startIndex = this.setPlaceholder() ? 1 : 0; // append the titleOption if necessary and skip the first option in the loop\n\n        if (this.options.hideDisabled) optionSelector += ':not(:disabled)';\n        var selectOptions = this.$element[0].querySelectorAll('select > *' + optionSelector);\n\n        function addDivider(config) {\n          var previousData = mainData[mainData.length - 1]; // ensure optgroup doesn't create back-to-back dividers\n\n          if (previousData && previousData.type === 'divider' && (previousData.optID || config.optID)) {\n            return;\n          }\n\n          config = config || {};\n          config.type = 'divider';\n          mainData.push(config);\n        }\n\n        function addOption(option, config) {\n          config = config || {};\n          config.divider = option.getAttribute('data-divider') === 'true';\n\n          if (config.divider) {\n            addDivider({\n              optID: config.optID\n            });\n          } else {\n            var liIndex = mainData.length,\n                cssText = option.style.cssText,\n                inlineStyle = cssText ? htmlEscape(cssText) : '',\n                optionClass = (option.className || '') + (config.optgroupClass || '');\n            if (config.optID) optionClass = 'opt ' + optionClass;\n            config.optionClass = optionClass.trim();\n            config.inlineStyle = inlineStyle;\n            config.text = option.textContent;\n            config.content = option.getAttribute('data-content');\n            config.tokens = option.getAttribute('data-tokens');\n            config.subtext = option.getAttribute('data-subtext');\n            config.icon = option.getAttribute('data-icon');\n            option.liIndex = liIndex;\n            config.display = config.content || config.text;\n            config.type = 'option';\n            config.index = liIndex;\n            config.option = option;\n            config.selected = !!option.selected;\n            config.disabled = config.disabled || !!option.disabled;\n            mainData.push(config);\n          }\n        }\n\n        function addOptgroup(index, selectOptions) {\n          var optgroup = selectOptions[index],\n              // skip placeholder option\n          previous = index - 1 < startIndex ? false : selectOptions[index - 1],\n              next = selectOptions[index + 1],\n              options = optgroup.querySelectorAll('option' + optionSelector);\n          if (!options.length) return;\n          var config = {\n            display: htmlEscape(optgroup.label),\n            subtext: optgroup.getAttribute('data-subtext'),\n            icon: optgroup.getAttribute('data-icon'),\n            type: 'optgroup-label',\n            optgroupClass: ' ' + (optgroup.className || '')\n          },\n              headerIndex,\n              lastIndex;\n          optID++;\n\n          if (previous) {\n            addDivider({\n              optID: optID\n            });\n          }\n\n          config.optID = optID;\n          mainData.push(config);\n\n          for (var j = 0, len = options.length; j < len; j++) {\n            var option = options[j];\n\n            if (j === 0) {\n              headerIndex = mainData.length - 1;\n              lastIndex = headerIndex + len;\n            }\n\n            addOption(option, {\n              headerIndex: headerIndex,\n              lastIndex: lastIndex,\n              optID: config.optID,\n              optgroupClass: config.optgroupClass,\n              disabled: optgroup.disabled\n            });\n          }\n\n          if (next) {\n            addDivider({\n              optID: optID\n            });\n          }\n        }\n\n        for (var len = selectOptions.length, i = startIndex; i < len; i++) {\n          var item = selectOptions[i];\n\n          if (item.tagName !== 'OPTGROUP') {\n            addOption(item, {});\n          } else {\n            addOptgroup(i, selectOptions);\n          }\n        }\n\n        this.selectpicker.main.data = this.selectpicker.current.data = mainData;\n      },\n      buildList: function buildList() {\n        var that = this,\n            selectData = this.selectpicker.main.data,\n            mainElements = [],\n            widestOptionLength = 0;\n\n        if ((that.options.showTick || that.multiple) && !elementTemplates.checkMark.parentNode) {\n          elementTemplates.checkMark.className = this.options.iconBase + ' ' + that.options.tickIcon + ' check-mark';\n          elementTemplates.a.appendChild(elementTemplates.checkMark);\n        }\n\n        function buildElement(item) {\n          var liElement,\n              combinedLength = 0;\n\n          switch (item.type) {\n            case 'divider':\n              liElement = generateOption.li(false, classNames.DIVIDER, item.optID ? item.optID + 'div' : undefined);\n              break;\n\n            case 'option':\n              liElement = generateOption.li(generateOption.a(generateOption.text.call(that, item), item.optionClass, item.inlineStyle), '', item.optID);\n\n              if (liElement.firstChild) {\n                liElement.firstChild.id = that.selectId + '-' + item.index;\n              }\n\n              break;\n\n            case 'optgroup-label':\n              liElement = generateOption.li(generateOption.label.call(that, item), 'dropdown-header' + item.optgroupClass, item.optID);\n              break;\n          }\n\n          item.element = liElement;\n          mainElements.push(liElement); // count the number of characters in the option - not perfect, but should work in most cases\n\n          if (item.display) combinedLength += item.display.length;\n          if (item.subtext) combinedLength += item.subtext.length; // if there is an icon, ensure this option's width is checked\n\n          if (item.icon) combinedLength += 1;\n\n          if (combinedLength > widestOptionLength) {\n            widestOptionLength = combinedLength; // guess which option is the widest\n            // use this when calculating menu width\n            // not perfect, but it's fast, and the width will be updating accordingly when scrolling\n\n            that.selectpicker.view.widestOption = mainElements[mainElements.length - 1];\n          }\n        }\n\n        for (var len = selectData.length, i = 0; i < len; i++) {\n          var item = selectData[i];\n          buildElement(item);\n        }\n\n        this.selectpicker.main.elements = this.selectpicker.current.elements = mainElements;\n      },\n      findLis: function findLis() {\n        return this.$menuInner.find('.inner > li');\n      },\n      render: function render() {\n        var that = this,\n            element = this.$element[0],\n            // ensure titleOption is appended and selected (if necessary) before getting selectedOptions\n        placeholderSelected = this.setPlaceholder() && element.selectedIndex === 0,\n            selectedOptions = getSelectedOptions(element, this.options.hideDisabled),\n            selectedCount = selectedOptions.length,\n            button = this.$button[0],\n            buttonInner = button.querySelector('.filter-option-inner-inner'),\n            multipleSeparator = document.createTextNode(this.options.multipleSeparator),\n            titleFragment = elementTemplates.fragment.cloneNode(false),\n            showCount,\n            countMax,\n            hasContent = false;\n        button.classList.toggle('bs-placeholder', that.multiple ? !selectedCount : !getSelectValues(element, selectedOptions));\n\n        if (!that.multiple && selectedOptions.length === 1) {\n          that.selectpicker.view.displayedValue = getSelectValues(element, selectedOptions);\n        }\n\n        if (this.options.selectedTextFormat === 'static') {\n          titleFragment = generateOption.text.call(this, {\n            text: this.options.title\n          }, true);\n        } else {\n          showCount = this.multiple && this.options.selectedTextFormat.indexOf('count') !== -1 && selectedCount > 1; // determine if the number of selected options will be shown (showCount === true)\n\n          if (showCount) {\n            countMax = this.options.selectedTextFormat.split('>');\n            showCount = countMax.length > 1 && selectedCount > countMax[1] || countMax.length === 1 && selectedCount >= 2;\n          } // only loop through all selected options if the count won't be shown\n\n\n          if (showCount === false) {\n            if (!placeholderSelected) {\n              for (var selectedIndex = 0; selectedIndex < selectedCount; selectedIndex++) {\n                if (selectedIndex < 50) {\n                  var option = selectedOptions[selectedIndex],\n                      thisData = this.selectpicker.main.data[option.liIndex],\n                      titleOptions = {};\n\n                  if (this.multiple && selectedIndex > 0) {\n                    titleFragment.appendChild(multipleSeparator.cloneNode(false));\n                  }\n\n                  if (option.title) {\n                    titleOptions.text = option.title;\n                  } else if (thisData) {\n                    if (thisData.content && that.options.showContent) {\n                      titleOptions.content = thisData.content.toString();\n                      hasContent = true;\n                    } else {\n                      if (that.options.showIcon) {\n                        titleOptions.icon = thisData.icon;\n                      }\n\n                      if (that.options.showSubtext && !that.multiple && thisData.subtext) titleOptions.subtext = ' ' + thisData.subtext;\n                      titleOptions.text = option.textContent.trim();\n                    }\n                  }\n\n                  titleFragment.appendChild(generateOption.text.call(this, titleOptions, true));\n                } else {\n                  break;\n                }\n              } // add ellipsis\n\n\n              if (selectedCount > 49) {\n                titleFragment.appendChild(document.createTextNode('...'));\n              }\n            }\n          } else {\n            var optionSelector = ':not([hidden]):not([data-hidden=\"true\"]):not([data-divider=\"true\"])';\n            if (this.options.hideDisabled) optionSelector += ':not(:disabled)'; // If this is a multiselect, and selectedTextFormat is count, then show 1 of 2 selected, etc.\n\n            var totalCount = this.$element[0].querySelectorAll('select > option' + optionSelector + ', optgroup' + optionSelector + ' option' + optionSelector).length,\n                tr8nText = typeof this.options.countSelectedText === 'function' ? this.options.countSelectedText(selectedCount, totalCount) : this.options.countSelectedText;\n            titleFragment = generateOption.text.call(this, {\n              text: tr8nText.replace('{0}', selectedCount.toString()).replace('{1}', totalCount.toString())\n            }, true);\n          }\n        }\n\n        if (this.options.title == undefined) {\n          // use .attr to ensure undefined is returned if title attribute is not set\n          this.options.title = this.$element.attr('title');\n        } // If the select doesn't have a title, then use the default, or if nothing is set at all, use noneSelectedText\n\n\n        if (!titleFragment.childNodes.length) {\n          titleFragment = generateOption.text.call(this, {\n            text: typeof this.options.title !== 'undefined' ? this.options.title : this.options.noneSelectedText\n          }, true);\n        } // strip all HTML tags and trim the result, then unescape any escaped tags\n\n\n        button.title = titleFragment.textContent.replace(/<[^>]*>?/g, '').trim();\n\n        if (this.options.sanitize && hasContent) {\n          sanitizeHtml([titleFragment], that.options.whiteList, that.options.sanitizeFn);\n        }\n\n        buttonInner.innerHTML = '';\n        buttonInner.appendChild(titleFragment);\n\n        if (version.major < 4 && this.$newElement[0].classList.contains('bs3-has-addon')) {\n          var filterExpand = button.querySelector('.filter-expand'),\n              clone = buttonInner.cloneNode(true);\n          clone.className = 'filter-expand';\n\n          if (filterExpand) {\n            button.replaceChild(clone, filterExpand);\n          } else {\n            button.appendChild(clone);\n          }\n        }\n\n        this.$element.trigger('rendered' + EVENT_KEY);\n      },\n\n      /**\r\n       * @param [style]\r\n       * @param [status]\r\n       */\n      setStyle: function setStyle(newStyle, status) {\n        var button = this.$button[0],\n            newElement = this.$newElement[0],\n            style = this.options.style.trim(),\n            buttonClass;\n\n        if (this.$element.attr('class')) {\n          this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device|bs-select-hidden|validate\\[.*\\]/gi, ''));\n        }\n\n        if (version.major < 4) {\n          newElement.classList.add('bs3');\n\n          if (newElement.parentNode.classList && newElement.parentNode.classList.contains('input-group') && (newElement.previousElementSibling || newElement.nextElementSibling) && (newElement.previousElementSibling || newElement.nextElementSibling).classList.contains('input-group-addon')) {\n            newElement.classList.add('bs3-has-addon');\n          }\n        }\n\n        if (newStyle) {\n          buttonClass = newStyle.trim();\n        } else {\n          buttonClass = style;\n        }\n\n        if (status == 'add') {\n          if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));\n        } else if (status == 'remove') {\n          if (buttonClass) button.classList.remove.apply(button.classList, buttonClass.split(' '));\n        } else {\n          if (style) button.classList.remove.apply(button.classList, style.split(' '));\n          if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));\n        }\n      },\n      liHeight: function liHeight(refresh) {\n        if (!refresh && (this.options.size === false || Object.keys(this.sizeInfo).length)) return;\n        var newElement = elementTemplates.div.cloneNode(false),\n            menu = elementTemplates.div.cloneNode(false),\n            menuInner = elementTemplates.div.cloneNode(false),\n            menuInnerInner = document.createElement('ul'),\n            divider = elementTemplates.li.cloneNode(false),\n            dropdownHeader = elementTemplates.li.cloneNode(false),\n            li,\n            a = elementTemplates.a.cloneNode(false),\n            text = elementTemplates.span.cloneNode(false),\n            header = this.options.header && this.$menu.find('.' + classNames.POPOVERHEADER).length > 0 ? this.$menu.find('.' + classNames.POPOVERHEADER)[0].cloneNode(true) : null,\n            search = this.options.liveSearch ? elementTemplates.div.cloneNode(false) : null,\n            actions = this.options.actionsBox && this.multiple && this.$menu.find('.bs-actionsbox').length > 0 ? this.$menu.find('.bs-actionsbox')[0].cloneNode(true) : null,\n            doneButton = this.options.doneButton && this.multiple && this.$menu.find('.bs-donebutton').length > 0 ? this.$menu.find('.bs-donebutton')[0].cloneNode(true) : null,\n            firstOption = this.$element.find('option')[0];\n        this.sizeInfo.selectWidth = this.$newElement[0].offsetWidth;\n        text.className = 'text';\n        a.className = 'dropdown-item ' + (firstOption ? firstOption.className : '');\n        newElement.className = this.$menu[0].parentNode.className + ' ' + classNames.SHOW;\n        newElement.style.width = 0; // ensure button width doesn't affect natural width of menu when calculating\n\n        if (this.options.width === 'auto') menu.style.minWidth = 0;\n        menu.className = classNames.MENU + ' ' + classNames.SHOW;\n        menuInner.className = 'inner ' + classNames.SHOW;\n        menuInnerInner.className = classNames.MENU + ' inner ' + (version.major === '4' ? classNames.SHOW : '');\n        divider.className = classNames.DIVIDER;\n        dropdownHeader.className = 'dropdown-header';\n        text.appendChild(document.createTextNode(\"\\u200B\"));\n\n        if (this.selectpicker.current.data.length) {\n          for (var i = 0; i < this.selectpicker.current.data.length; i++) {\n            var data = this.selectpicker.current.data[i];\n\n            if (data.type === 'option') {\n              li = data.element;\n              break;\n            }\n          }\n        } else {\n          li = elementTemplates.li.cloneNode(false);\n          a.appendChild(text);\n          li.appendChild(a);\n        }\n\n        dropdownHeader.appendChild(text.cloneNode(true));\n\n        if (this.selectpicker.view.widestOption) {\n          menuInnerInner.appendChild(this.selectpicker.view.widestOption.cloneNode(true));\n        }\n\n        menuInnerInner.appendChild(li);\n        menuInnerInner.appendChild(divider);\n        menuInnerInner.appendChild(dropdownHeader);\n        if (header) menu.appendChild(header);\n\n        if (search) {\n          var input = document.createElement('input');\n          search.className = 'bs-searchbox';\n          input.className = 'form-control';\n          search.appendChild(input);\n          menu.appendChild(search);\n        }\n\n        if (actions) menu.appendChild(actions);\n        menuInner.appendChild(menuInnerInner);\n        menu.appendChild(menuInner);\n        if (doneButton) menu.appendChild(doneButton);\n        newElement.appendChild(menu);\n        document.body.appendChild(newElement);\n        var liHeight = li.offsetHeight,\n            dropdownHeaderHeight = dropdownHeader ? dropdownHeader.offsetHeight : 0,\n            headerHeight = header ? header.offsetHeight : 0,\n            searchHeight = search ? search.offsetHeight : 0,\n            actionsHeight = actions ? actions.offsetHeight : 0,\n            doneButtonHeight = doneButton ? doneButton.offsetHeight : 0,\n            dividerHeight = $(divider).outerHeight(true),\n            // fall back to jQuery if getComputedStyle is not supported\n        menuStyle = window.getComputedStyle ? window.getComputedStyle(menu) : false,\n            menuWidth = menu.offsetWidth,\n            $menu = menuStyle ? null : $(menu),\n            menuPadding = {\n          vert: toInteger(menuStyle ? menuStyle.paddingTop : $menu.css('paddingTop')) + toInteger(menuStyle ? menuStyle.paddingBottom : $menu.css('paddingBottom')) + toInteger(menuStyle ? menuStyle.borderTopWidth : $menu.css('borderTopWidth')) + toInteger(menuStyle ? menuStyle.borderBottomWidth : $menu.css('borderBottomWidth')),\n          horiz: toInteger(menuStyle ? menuStyle.paddingLeft : $menu.css('paddingLeft')) + toInteger(menuStyle ? menuStyle.paddingRight : $menu.css('paddingRight')) + toInteger(menuStyle ? menuStyle.borderLeftWidth : $menu.css('borderLeftWidth')) + toInteger(menuStyle ? menuStyle.borderRightWidth : $menu.css('borderRightWidth'))\n        },\n            menuExtras = {\n          vert: menuPadding.vert + toInteger(menuStyle ? menuStyle.marginTop : $menu.css('marginTop')) + toInteger(menuStyle ? menuStyle.marginBottom : $menu.css('marginBottom')) + 2,\n          horiz: menuPadding.horiz + toInteger(menuStyle ? menuStyle.marginLeft : $menu.css('marginLeft')) + toInteger(menuStyle ? menuStyle.marginRight : $menu.css('marginRight')) + 2\n        },\n            scrollBarWidth;\n        menuInner.style.overflowY = 'scroll';\n        scrollBarWidth = menu.offsetWidth - menuWidth;\n        document.body.removeChild(newElement);\n        this.sizeInfo.liHeight = liHeight;\n        this.sizeInfo.dropdownHeaderHeight = dropdownHeaderHeight;\n        this.sizeInfo.headerHeight = headerHeight;\n        this.sizeInfo.searchHeight = searchHeight;\n        this.sizeInfo.actionsHeight = actionsHeight;\n        this.sizeInfo.doneButtonHeight = doneButtonHeight;\n        this.sizeInfo.dividerHeight = dividerHeight;\n        this.sizeInfo.menuPadding = menuPadding;\n        this.sizeInfo.menuExtras = menuExtras;\n        this.sizeInfo.menuWidth = menuWidth;\n        this.sizeInfo.menuInnerInnerWidth = menuWidth - menuPadding.horiz;\n        this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth;\n        this.sizeInfo.scrollBarWidth = scrollBarWidth;\n        this.sizeInfo.selectHeight = this.$newElement[0].offsetHeight;\n        this.setPositionData();\n      },\n      getSelectPosition: function getSelectPosition() {\n        var that = this,\n            $window = $(window),\n            pos = that.$newElement.offset(),\n            $container = $(that.options.container),\n            containerPos;\n\n        if (that.options.container && $container.length && !$container.is('body')) {\n          containerPos = $container.offset();\n          containerPos.top += parseInt($container.css('borderTopWidth'));\n          containerPos.left += parseInt($container.css('borderLeftWidth'));\n        } else {\n          containerPos = {\n            top: 0,\n            left: 0\n          };\n        }\n\n        var winPad = that.options.windowPadding;\n        this.sizeInfo.selectOffsetTop = pos.top - containerPos.top - $window.scrollTop();\n        this.sizeInfo.selectOffsetBot = $window.height() - this.sizeInfo.selectOffsetTop - this.sizeInfo.selectHeight - containerPos.top - winPad[2];\n        this.sizeInfo.selectOffsetLeft = pos.left - containerPos.left - $window.scrollLeft();\n        this.sizeInfo.selectOffsetRight = $window.width() - this.sizeInfo.selectOffsetLeft - this.sizeInfo.selectWidth - containerPos.left - winPad[1];\n        this.sizeInfo.selectOffsetTop -= winPad[0];\n        this.sizeInfo.selectOffsetLeft -= winPad[3];\n      },\n      setMenuSize: function setMenuSize(isAuto) {\n        this.getSelectPosition();\n\n        var selectWidth = this.sizeInfo.selectWidth,\n            liHeight = this.sizeInfo.liHeight,\n            headerHeight = this.sizeInfo.headerHeight,\n            searchHeight = this.sizeInfo.searchHeight,\n            actionsHeight = this.sizeInfo.actionsHeight,\n            doneButtonHeight = this.sizeInfo.doneButtonHeight,\n            divHeight = this.sizeInfo.dividerHeight,\n            menuPadding = this.sizeInfo.menuPadding,\n            menuInnerHeight,\n            menuHeight,\n            divLength = 0,\n            minHeight,\n            _minHeight,\n            maxHeight,\n            menuInnerMinHeight,\n            estimate,\n            isDropup;\n\n        if (this.options.dropupAuto) {\n          // Get the estimated height of the menu without scrollbars.\n          // This is useful for smaller menus, where there might be plenty of room\n          // below the button without setting dropup, but we can't know\n          // the exact height of the menu until createView is called later\n          estimate = liHeight * this.selectpicker.current.elements.length + menuPadding.vert;\n          isDropup = this.sizeInfo.selectOffsetTop - this.sizeInfo.selectOffsetBot > this.sizeInfo.menuExtras.vert && estimate + this.sizeInfo.menuExtras.vert + 50 > this.sizeInfo.selectOffsetBot; // ensure dropup doesn't change while searching (so menu doesn't bounce back and forth)\n\n          if (this.selectpicker.isSearching === true) {\n            isDropup = this.selectpicker.dropup;\n          }\n\n          this.$newElement.toggleClass(classNames.DROPUP, isDropup);\n          this.selectpicker.dropup = isDropup;\n        }\n\n        if (this.options.size === 'auto') {\n          _minHeight = this.selectpicker.current.elements.length > 3 ? this.sizeInfo.liHeight * 3 + this.sizeInfo.menuExtras.vert - 2 : 0;\n          menuHeight = this.sizeInfo.selectOffsetBot - this.sizeInfo.menuExtras.vert;\n          minHeight = _minHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;\n          menuInnerMinHeight = Math.max(_minHeight - menuPadding.vert, 0);\n\n          if (this.$newElement.hasClass(classNames.DROPUP)) {\n            menuHeight = this.sizeInfo.selectOffsetTop - this.sizeInfo.menuExtras.vert;\n          }\n\n          maxHeight = menuHeight;\n          menuInnerHeight = menuHeight - headerHeight - searchHeight - actionsHeight - doneButtonHeight - menuPadding.vert;\n        } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {\n          for (var i = 0; i < this.options.size; i++) {\n            if (this.selectpicker.current.data[i].type === 'divider') divLength++;\n          }\n\n          menuHeight = liHeight * this.options.size + divLength * divHeight + menuPadding.vert;\n          menuInnerHeight = menuHeight - menuPadding.vert;\n          maxHeight = menuHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;\n          minHeight = menuInnerMinHeight = '';\n        }\n\n        this.$menu.css({\n          'max-height': maxHeight + 'px',\n          'overflow': 'hidden',\n          'min-height': minHeight + 'px'\n        });\n        this.$menuInner.css({\n          'max-height': menuInnerHeight + 'px',\n          'overflow-y': 'auto',\n          'min-height': menuInnerMinHeight + 'px'\n        }); // ensure menuInnerHeight is always a positive number to prevent issues calculating chunkSize in createView\n\n        this.sizeInfo.menuInnerHeight = Math.max(menuInnerHeight, 1);\n\n        if (this.selectpicker.current.data.length && this.selectpicker.current.data[this.selectpicker.current.data.length - 1].position > this.sizeInfo.menuInnerHeight) {\n          this.sizeInfo.hasScrollBar = true;\n          this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth + this.sizeInfo.scrollBarWidth;\n        }\n\n        if (this.options.dropdownAlignRight === 'auto') {\n          this.$menu.toggleClass(classNames.MENURIGHT, this.sizeInfo.selectOffsetLeft > this.sizeInfo.selectOffsetRight && this.sizeInfo.selectOffsetRight < this.sizeInfo.totalMenuWidth - selectWidth);\n        }\n\n        if (this.dropdown && this.dropdown._popper) this.dropdown._popper.update();\n      },\n      setSize: function setSize(refresh) {\n        this.liHeight(refresh);\n        if (this.options.header) this.$menu.css('padding-top', 0);\n\n        if (this.options.size !== false) {\n          var that = this,\n              $window = $(window);\n          this.setMenuSize();\n\n          if (this.options.liveSearch) {\n            this.$searchbox.off('input.setMenuSize propertychange.setMenuSize').on('input.setMenuSize propertychange.setMenuSize', function () {\n              return that.setMenuSize();\n            });\n          }\n\n          if (this.options.size === 'auto') {\n            $window.off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize').on('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize', function () {\n              return that.setMenuSize();\n            });\n          } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {\n            $window.off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize');\n          }\n        }\n\n        this.createView(false, true, refresh);\n      },\n      setWidth: function setWidth() {\n        var that = this;\n\n        if (this.options.width === 'auto') {\n          requestAnimationFrame(function () {\n            that.$menu.css('min-width', '0');\n            that.$element.on('loaded' + EVENT_KEY, function () {\n              that.liHeight();\n              that.setMenuSize(); // Get correct width if element is hidden\n\n              var $selectClone = that.$newElement.clone().appendTo('body'),\n                  btnWidth = $selectClone.css('width', 'auto').children('button').outerWidth();\n              $selectClone.remove(); // Set width to whatever's larger, button title or longest option\n\n              that.sizeInfo.selectWidth = Math.max(that.sizeInfo.totalMenuWidth, btnWidth);\n              that.$newElement.css('width', that.sizeInfo.selectWidth + 'px');\n            });\n          });\n        } else if (this.options.width === 'fit') {\n          // Remove inline min-width so width can be changed from 'auto'\n          this.$menu.css('min-width', '');\n          this.$newElement.css('width', '').addClass('fit-width');\n        } else if (this.options.width) {\n          // Remove inline min-width so width can be changed from 'auto'\n          this.$menu.css('min-width', '');\n          this.$newElement.css('width', this.options.width);\n        } else {\n          // Remove inline min-width/width so width can be changed\n          this.$menu.css('min-width', '');\n          this.$newElement.css('width', '');\n        } // Remove fit-width class if width is changed programmatically\n\n\n        if (this.$newElement.hasClass('fit-width') && this.options.width !== 'fit') {\n          this.$newElement[0].classList.remove('fit-width');\n        }\n      },\n      selectPosition: function selectPosition() {\n        this.$bsContainer = $('<div class=\"bs-container\" />');\n\n        var that = this,\n            $container = $(this.options.container),\n            pos,\n            containerPos,\n            actualHeight,\n            getPlacement = function getPlacement($element) {\n          var containerPosition = {},\n              // fall back to dropdown's default display setting if display is not manually set\n          display = that.options.display || ( // Bootstrap 3 doesn't have $.fn.dropdown.Constructor.Default\n          $.fn.dropdown.Constructor.Default ? $.fn.dropdown.Constructor.Default.display : false);\n          that.$bsContainer.addClass($element.attr('class').replace(/form-control|fit-width/gi, '')).toggleClass(classNames.DROPUP, $element.hasClass(classNames.DROPUP));\n          pos = $element.offset();\n\n          if (!$container.is('body')) {\n            containerPos = $container.offset();\n            containerPos.top += parseInt($container.css('borderTopWidth')) - $container.scrollTop();\n            containerPos.left += parseInt($container.css('borderLeftWidth')) - $container.scrollLeft();\n          } else {\n            containerPos = {\n              top: 0,\n              left: 0\n            };\n          }\n\n          actualHeight = $element.hasClass(classNames.DROPUP) ? 0 : $element[0].offsetHeight; // Bootstrap 4+ uses Popper for menu positioning\n\n          if (version.major < 4 || display === 'static') {\n            containerPosition.top = pos.top - containerPos.top + actualHeight;\n            containerPosition.left = pos.left - containerPos.left;\n          }\n\n          containerPosition.width = $element[0].offsetWidth;\n          that.$bsContainer.css(containerPosition);\n        };\n\n        this.$button.on('click.bs.dropdown.data-api', function () {\n          if (that.isDisabled()) {\n            return;\n          }\n\n          getPlacement(that.$newElement);\n          that.$bsContainer.appendTo(that.options.container).toggleClass(classNames.SHOW, !that.$button.hasClass(classNames.SHOW)).append(that.$menu);\n        });\n        $(window).off('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId).on('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId, function () {\n          var isActive = that.$newElement.hasClass(classNames.SHOW);\n          if (isActive) getPlacement(that.$newElement);\n        });\n        this.$element.on('hide' + EVENT_KEY, function () {\n          that.$menu.data('height', that.$menu.height());\n          that.$bsContainer.detach();\n        });\n      },\n      setOptionStatus: function setOptionStatus(selectedOnly) {\n        var that = this;\n        that.noScroll = false;\n\n        if (that.selectpicker.view.visibleElements && that.selectpicker.view.visibleElements.length) {\n          for (var i = 0; i < that.selectpicker.view.visibleElements.length; i++) {\n            var liData = that.selectpicker.current.data[i + that.selectpicker.view.position0],\n                option = liData.option;\n\n            if (option) {\n              if (selectedOnly !== true) {\n                that.setDisabled(liData.index, liData.disabled);\n              }\n\n              that.setSelected(liData.index, option.selected);\n            }\n          }\n        }\n      },\n\n      /**\r\n       * @param {number} index - the index of the option that is being changed\r\n       * @param {boolean} selected - true if the option is being selected, false if being deselected\r\n       */\n      setSelected: function setSelected(index, selected) {\n        var li = this.selectpicker.main.elements[index],\n            liData = this.selectpicker.main.data[index],\n            activeIndexIsSet = this.activeIndex !== undefined,\n            thisIsActive = this.activeIndex === index,\n            prevActive,\n            a,\n            // if current option is already active\n        // OR\n        // if the current option is being selected, it's NOT multiple, and\n        // activeIndex is undefined:\n        //  - when the menu is first being opened, OR\n        //  - after a search has been performed, OR\n        //  - when retainActive is false when selecting a new option (i.e. index of the newly selected option is not the same as the current activeIndex)\n        keepActive = thisIsActive || selected && !this.multiple && !activeIndexIsSet;\n        liData.selected = selected;\n        a = li.firstChild;\n\n        if (selected) {\n          this.selectedIndex = index;\n        }\n\n        li.classList.toggle('selected', selected);\n\n        if (keepActive) {\n          this.focusItem(li, liData);\n          this.selectpicker.view.currentActive = li;\n          this.activeIndex = index;\n        } else {\n          this.defocusItem(li);\n        }\n\n        if (a) {\n          a.classList.toggle('selected', selected);\n\n          if (selected) {\n            a.setAttribute('aria-selected', true);\n          } else {\n            if (this.multiple) {\n              a.setAttribute('aria-selected', false);\n            } else {\n              a.removeAttribute('aria-selected');\n            }\n          }\n        }\n\n        if (!keepActive && !activeIndexIsSet && selected && this.prevActiveIndex !== undefined) {\n          prevActive = this.selectpicker.main.elements[this.prevActiveIndex];\n          this.defocusItem(prevActive);\n        }\n      },\n\n      /**\r\n       * @param {number} index - the index of the option that is being disabled\r\n       * @param {boolean} disabled - true if the option is being disabled, false if being enabled\r\n       */\n      setDisabled: function setDisabled(index, disabled) {\n        var li = this.selectpicker.main.elements[index],\n            a;\n        this.selectpicker.main.data[index].disabled = disabled;\n        a = li.firstChild;\n        li.classList.toggle(classNames.DISABLED, disabled);\n\n        if (a) {\n          if (version.major === '4') a.classList.toggle(classNames.DISABLED, disabled);\n\n          if (disabled) {\n            a.setAttribute('aria-disabled', disabled);\n            a.setAttribute('tabindex', -1);\n          } else {\n            a.removeAttribute('aria-disabled');\n            a.setAttribute('tabindex', 0);\n          }\n        }\n      },\n      isDisabled: function isDisabled() {\n        return this.$element[0].disabled;\n      },\n      checkDisabled: function checkDisabled() {\n        if (this.isDisabled()) {\n          this.$newElement[0].classList.add(classNames.DISABLED);\n          this.$button.addClass(classNames.DISABLED).attr('aria-disabled', true);\n        } else {\n          if (this.$button[0].classList.contains(classNames.DISABLED)) {\n            this.$newElement[0].classList.remove(classNames.DISABLED);\n            this.$button.removeClass(classNames.DISABLED).attr('aria-disabled', false);\n          }\n        }\n      },\n      clickListener: function clickListener() {\n        var that = this,\n            $document = $(document);\n        $document.data('spaceSelect', false);\n        this.$button.on('keyup', function (e) {\n          if (/(32)/.test(e.keyCode.toString(10)) && $document.data('spaceSelect')) {\n            e.preventDefault();\n            $document.data('spaceSelect', false);\n          }\n        });\n        this.$newElement.on('show.bs.dropdown', function () {\n          if (version.major > 3 && !that.dropdown) {\n            that.dropdown = that.$button.data('bs.dropdown');\n            that.dropdown._menu = that.$menu[0];\n          }\n        });\n        this.$button.on('click.bs.dropdown.data-api', function () {\n          if (!that.$newElement.hasClass(classNames.SHOW)) {\n            that.setSize();\n          }\n        });\n\n        function setFocus() {\n          if (that.options.liveSearch) {\n            that.$searchbox.trigger('focus');\n          } else {\n            that.$menuInner.trigger('focus');\n          }\n        }\n\n        function checkPopperExists() {\n          if (that.dropdown && that.dropdown._popper && that.dropdown._popper.state.isCreated) {\n            setFocus();\n          } else {\n            requestAnimationFrame(checkPopperExists);\n          }\n        }\n\n        this.$element.on('shown' + EVENT_KEY, function () {\n          if (that.$menuInner[0].scrollTop !== that.selectpicker.view.scrollTop) {\n            that.$menuInner[0].scrollTop = that.selectpicker.view.scrollTop;\n          }\n\n          if (version.major > 3) {\n            requestAnimationFrame(checkPopperExists);\n          } else {\n            setFocus();\n          }\n        }); // ensure posinset and setsize are correct before selecting an option via a click\n\n        this.$menuInner.on('mouseenter', 'li a', function (e) {\n          var hoverLi = this.parentElement,\n              position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,\n              index = Array.prototype.indexOf.call(hoverLi.parentElement.children, hoverLi),\n              hoverData = that.selectpicker.current.data[index + position0];\n          that.focusItem(hoverLi, hoverData, true);\n        });\n        this.$menuInner.on('click', 'li a', function (e, retainActive) {\n          var $this = $(this),\n              element = that.$element[0],\n              position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,\n              clickedData = that.selectpicker.current.data[$this.parent().index() + position0],\n              clickedIndex = clickedData.index,\n              prevValue = getSelectValues(element),\n              prevIndex = element.selectedIndex,\n              prevOption = element.options[prevIndex],\n              triggerChange = true; // Don't close on multi choice menu\n\n          if (that.multiple && that.options.maxOptions !== 1) {\n            e.stopPropagation();\n          }\n\n          e.preventDefault(); // Don't run if the select is disabled\n\n          if (!that.isDisabled() && !$this.parent().hasClass(classNames.DISABLED)) {\n            var option = clickedData.option,\n                $option = $(option),\n                state = option.selected,\n                $optgroup = $option.parent('optgroup'),\n                $optgroupOptions = $optgroup.find('option'),\n                maxOptions = that.options.maxOptions,\n                maxOptionsGrp = $optgroup.data('maxOptions') || false;\n            if (clickedIndex === that.activeIndex) retainActive = true;\n\n            if (!retainActive) {\n              that.prevActiveIndex = that.activeIndex;\n              that.activeIndex = undefined;\n            }\n\n            if (!that.multiple) {\n              // Deselect all others if not multi select box\n              if (prevOption) prevOption.selected = false;\n              option.selected = true;\n              that.setSelected(clickedIndex, true);\n            } else {\n              // Toggle the one we have chosen if we are multi select.\n              option.selected = !state;\n              that.setSelected(clickedIndex, !state);\n              that.focusedParent.focus();\n\n              if (maxOptions !== false || maxOptionsGrp !== false) {\n                var maxReached = maxOptions < getSelectedOptions(element).length,\n                    maxReachedGrp = maxOptionsGrp < $optgroup.find('option:selected').length;\n\n                if (maxOptions && maxReached || maxOptionsGrp && maxReachedGrp) {\n                  if (maxOptions && maxOptions == 1) {\n                    element.selectedIndex = -1;\n                    option.selected = true;\n                    that.setOptionStatus(true);\n                  } else if (maxOptionsGrp && maxOptionsGrp == 1) {\n                    for (var i = 0; i < $optgroupOptions.length; i++) {\n                      var _option = $optgroupOptions[i];\n                      _option.selected = false;\n                      that.setSelected(_option.liIndex, false);\n                    }\n\n                    option.selected = true;\n                    that.setSelected(clickedIndex, true);\n                  } else {\n                    var maxOptionsText = typeof that.options.maxOptionsText === 'string' ? [that.options.maxOptionsText, that.options.maxOptionsText] : that.options.maxOptionsText,\n                        maxOptionsArr = typeof maxOptionsText === 'function' ? maxOptionsText(maxOptions, maxOptionsGrp) : maxOptionsText,\n                        maxTxt = maxOptionsArr[0].replace('{n}', maxOptions),\n                        maxTxtGrp = maxOptionsArr[1].replace('{n}', maxOptionsGrp),\n                        $notify = $('<div class=\"notify\"></div>'); // If {var} is set in array, replace it\n\n                    /** @deprecated */\n\n                    if (maxOptionsArr[2]) {\n                      maxTxt = maxTxt.replace('{var}', maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);\n                      maxTxtGrp = maxTxtGrp.replace('{var}', maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);\n                    }\n\n                    option.selected = false;\n                    that.$menu.append($notify);\n\n                    if (maxOptions && maxReached) {\n                      $notify.append($('<div>' + maxTxt + '</div>'));\n                      triggerChange = false;\n                      that.$element.trigger('maxReached' + EVENT_KEY);\n                    }\n\n                    if (maxOptionsGrp && maxReachedGrp) {\n                      $notify.append($('<div>' + maxTxtGrp + '</div>'));\n                      triggerChange = false;\n                      that.$element.trigger('maxReachedGrp' + EVENT_KEY);\n                    }\n\n                    setTimeout(function () {\n                      that.setSelected(clickedIndex, false);\n                    }, 10);\n                    $notify[0].classList.add('fadeOut');\n                    setTimeout(function () {\n                      $notify.remove();\n                    }, 1050);\n                  }\n                }\n              }\n            }\n\n            if (!that.multiple || that.multiple && that.options.maxOptions === 1) {\n              that.$button.trigger('focus');\n            } else if (that.options.liveSearch) {\n              that.$searchbox.trigger('focus');\n            } // Trigger select 'change'\n\n\n            if (triggerChange) {\n              if (that.multiple || prevIndex !== element.selectedIndex) {\n                // $option.prop('selected') is current option state (selected/unselected). prevValue is the value of the select prior to being changed.\n                changedArguments = [option.index, $option.prop('selected'), prevValue];\n                that.$element.triggerNative('change');\n              }\n            }\n          }\n        });\n        this.$menu.on('click', 'li.' + classNames.DISABLED + ' a, .' + classNames.POPOVERHEADER + ', .' + classNames.POPOVERHEADER + ' :not(.close)', function (e) {\n          if (e.currentTarget == this) {\n            e.preventDefault();\n            e.stopPropagation();\n\n            if (that.options.liveSearch && !$(e.target).hasClass('close')) {\n              that.$searchbox.trigger('focus');\n            } else {\n              that.$button.trigger('focus');\n            }\n          }\n        });\n        this.$menuInner.on('click', '.divider, .dropdown-header', function (e) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          if (that.options.liveSearch) {\n            that.$searchbox.trigger('focus');\n          } else {\n            that.$button.trigger('focus');\n          }\n        });\n        this.$menu.on('click', '.' + classNames.POPOVERHEADER + ' .close', function () {\n          that.$button.trigger('click');\n        });\n        this.$searchbox.on('click', function (e) {\n          e.stopPropagation();\n        });\n        this.$menu.on('click', '.actions-btn', function (e) {\n          if (that.options.liveSearch) {\n            that.$searchbox.trigger('focus');\n          } else {\n            that.$button.trigger('focus');\n          }\n\n          e.preventDefault();\n          e.stopPropagation();\n\n          if ($(this).hasClass('bs-select-all')) {\n            that.selectAll();\n          } else {\n            that.deselectAll();\n          }\n        });\n        this.$button.on('focus' + EVENT_KEY, function (e) {\n          var tabindex = that.$element[0].getAttribute('tabindex'); // only change when button is actually focused\n\n          if (tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {\n            // apply select element's tabindex to ensure correct order is followed when tabbing to the next element\n            this.setAttribute('tabindex', tabindex); // set element's tabindex to -1 to allow for reverse tabbing\n\n            that.$element[0].setAttribute('tabindex', -1);\n            that.selectpicker.view.tabindex = tabindex;\n          }\n        }).on('blur' + EVENT_KEY, function (e) {\n          // revert everything to original tabindex\n          if (that.selectpicker.view.tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {\n            that.$element[0].setAttribute('tabindex', that.selectpicker.view.tabindex);\n            this.setAttribute('tabindex', -1);\n            that.selectpicker.view.tabindex = undefined;\n          }\n        });\n        this.$element.on('change' + EVENT_KEY, function () {\n          that.render();\n          that.$element.trigger('changed' + EVENT_KEY, changedArguments);\n          changedArguments = null;\n        }).on('focus' + EVENT_KEY, function () {\n          if (!that.options.mobile) that.$button[0].focus();\n        });\n      },\n      liveSearchListener: function liveSearchListener() {\n        var that = this;\n        this.$button.on('click.bs.dropdown.data-api', function () {\n          if (!!that.$searchbox.val()) {\n            that.$searchbox.val('');\n            that.selectpicker.search.previousValue = undefined;\n          }\n        });\n        this.$searchbox.on('click.bs.dropdown.data-api focus.bs.dropdown.data-api touchend.bs.dropdown.data-api', function (e) {\n          e.stopPropagation();\n        });\n        this.$searchbox.on('input propertychange', function () {\n          var searchValue = that.$searchbox[0].value;\n          that.selectpicker.search.elements = [];\n          that.selectpicker.search.data = [];\n\n          if (searchValue) {\n            var i,\n                searchMatch = [],\n                q = searchValue.toUpperCase(),\n                cache = {},\n                cacheArr = [],\n                searchStyle = that._searchStyle(),\n                normalizeSearch = that.options.liveSearchNormalize;\n\n            if (normalizeSearch) q = normalizeToBase(q);\n\n            for (var i = 0; i < that.selectpicker.main.data.length; i++) {\n              var li = that.selectpicker.main.data[i];\n\n              if (!cache[i]) {\n                cache[i] = stringSearch(li, q, searchStyle, normalizeSearch);\n              }\n\n              if (cache[i] && li.headerIndex !== undefined && cacheArr.indexOf(li.headerIndex) === -1) {\n                if (li.headerIndex > 0) {\n                  cache[li.headerIndex - 1] = true;\n                  cacheArr.push(li.headerIndex - 1);\n                }\n\n                cache[li.headerIndex] = true;\n                cacheArr.push(li.headerIndex);\n                cache[li.lastIndex + 1] = true;\n              }\n\n              if (cache[i] && li.type !== 'optgroup-label') cacheArr.push(i);\n            }\n\n            for (var i = 0, cacheLen = cacheArr.length; i < cacheLen; i++) {\n              var index = cacheArr[i],\n                  prevIndex = cacheArr[i - 1],\n                  li = that.selectpicker.main.data[index],\n                  liPrev = that.selectpicker.main.data[prevIndex];\n\n              if (li.type !== 'divider' || li.type === 'divider' && liPrev && liPrev.type !== 'divider' && cacheLen - 1 !== i) {\n                that.selectpicker.search.data.push(li);\n                searchMatch.push(that.selectpicker.main.elements[index]);\n              }\n            }\n\n            that.activeIndex = undefined;\n            that.noScroll = true;\n            that.$menuInner.scrollTop(0);\n            that.selectpicker.search.elements = searchMatch;\n            that.createView(true);\n            showNoResults.call(that, searchMatch, searchValue);\n          } else if (that.selectpicker.search.previousValue) {\n            // for IE11 (#2402)\n            that.$menuInner.scrollTop(0);\n            that.createView(false);\n          }\n\n          that.selectpicker.search.previousValue = searchValue;\n        });\n      },\n      _searchStyle: function _searchStyle() {\n        return this.options.liveSearchStyle || 'contains';\n      },\n      val: function val(value) {\n        var element = this.$element[0];\n\n        if (typeof value !== 'undefined') {\n          var prevValue = getSelectValues(element);\n          changedArguments = [null, null, prevValue];\n          this.$element.val(value).trigger('changed' + EVENT_KEY, changedArguments);\n\n          if (this.$newElement.hasClass(classNames.SHOW)) {\n            if (this.multiple) {\n              this.setOptionStatus(true);\n            } else {\n              var liSelectedIndex = (element.options[element.selectedIndex] || {}).liIndex;\n\n              if (typeof liSelectedIndex === 'number') {\n                this.setSelected(this.selectedIndex, false);\n                this.setSelected(liSelectedIndex, true);\n              }\n            }\n          }\n\n          this.render();\n          changedArguments = null;\n          return this.$element;\n        } else {\n          return this.$element.val();\n        }\n      },\n      changeAll: function changeAll(status) {\n        if (!this.multiple) return;\n        if (typeof status === 'undefined') status = true;\n        var element = this.$element[0],\n            previousSelected = 0,\n            currentSelected = 0,\n            prevValue = getSelectValues(element);\n        element.classList.add('bs-select-hidden');\n\n        for (var i = 0, data = this.selectpicker.current.data, len = data.length; i < len; i++) {\n          var liData = data[i],\n              option = liData.option;\n\n          if (option && !liData.disabled && liData.type !== 'divider') {\n            if (liData.selected) previousSelected++;\n            option.selected = status;\n            if (status === true) currentSelected++;\n          }\n        }\n\n        element.classList.remove('bs-select-hidden');\n        if (previousSelected === currentSelected) return;\n        this.setOptionStatus();\n        changedArguments = [null, null, prevValue];\n        this.$element.triggerNative('change');\n      },\n      selectAll: function selectAll() {\n        return this.changeAll(true);\n      },\n      deselectAll: function deselectAll() {\n        return this.changeAll(false);\n      },\n      toggle: function toggle(e) {\n        e = e || window.event;\n        if (e) e.stopPropagation();\n        this.$button.trigger('click.bs.dropdown.data-api');\n      },\n      keydown: function keydown(e) {\n        var $this = $(this),\n            isToggle = $this.hasClass('dropdown-toggle'),\n            $parent = isToggle ? $this.closest('.dropdown') : $this.closest(Selector.MENU),\n            that = $parent.data('this'),\n            $items = that.findLis(),\n            index,\n            isActive,\n            liActive,\n            activeLi,\n            offset,\n            updateScroll = false,\n            downOnTab = e.which === keyCodes.TAB && !isToggle && !that.options.selectOnTab,\n            isArrowKey = REGEXP_ARROW.test(e.which) || downOnTab,\n            scrollTop = that.$menuInner[0].scrollTop,\n            isVirtual = that.isVirtual(),\n            position0 = isVirtual === true ? that.selectpicker.view.position0 : 0; // do nothing if a function key is pressed\n\n        if (e.which >= 112 && e.which <= 123) return;\n        isActive = that.$newElement.hasClass(classNames.SHOW);\n\n        if (!isActive && (isArrowKey || e.which >= 48 && e.which <= 57 || e.which >= 96 && e.which <= 105 || e.which >= 65 && e.which <= 90)) {\n          that.$button.trigger('click.bs.dropdown.data-api');\n\n          if (that.options.liveSearch) {\n            that.$searchbox.trigger('focus');\n            return;\n          }\n        }\n\n        if (e.which === keyCodes.ESCAPE && isActive) {\n          e.preventDefault();\n          that.$button.trigger('click.bs.dropdown.data-api').trigger('focus');\n        }\n\n        if (isArrowKey) {\n          // if up or down\n          if (!$items.length) return;\n          liActive = that.selectpicker.main.elements[that.activeIndex];\n          index = liActive ? Array.prototype.indexOf.call(liActive.parentElement.children, liActive) : -1;\n\n          if (index !== -1) {\n            that.defocusItem(liActive);\n          }\n\n          if (e.which === keyCodes.ARROW_UP) {\n            // up\n            if (index !== -1) index--;\n            if (index + position0 < 0) index += $items.length;\n\n            if (!that.selectpicker.view.canHighlight[index + position0]) {\n              index = that.selectpicker.view.canHighlight.slice(0, index + position0).lastIndexOf(true) - position0;\n              if (index === -1) index = $items.length - 1;\n            }\n          } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) {\n            // down\n            index++;\n            if (index + position0 >= that.selectpicker.view.canHighlight.length) index = that.selectpicker.view.firstHighlightIndex;\n\n            if (!that.selectpicker.view.canHighlight[index + position0]) {\n              index = index + 1 + that.selectpicker.view.canHighlight.slice(index + position0 + 1).indexOf(true);\n            }\n          }\n\n          e.preventDefault();\n          var liActiveIndex = position0 + index;\n\n          if (e.which === keyCodes.ARROW_UP) {\n            // up\n            // scroll to bottom and highlight last option\n            if (position0 === 0 && index === $items.length - 1) {\n              that.$menuInner[0].scrollTop = that.$menuInner[0].scrollHeight;\n              liActiveIndex = that.selectpicker.current.elements.length - 1;\n            } else {\n              activeLi = that.selectpicker.current.data[liActiveIndex];\n              offset = activeLi.position - activeLi.height;\n              updateScroll = offset < scrollTop;\n            }\n          } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) {\n            // down\n            // scroll to top and highlight first option\n            if (index === that.selectpicker.view.firstHighlightIndex) {\n              that.$menuInner[0].scrollTop = 0;\n              liActiveIndex = that.selectpicker.view.firstHighlightIndex;\n            } else {\n              activeLi = that.selectpicker.current.data[liActiveIndex];\n              offset = activeLi.position - that.sizeInfo.menuInnerHeight;\n              updateScroll = offset > scrollTop;\n            }\n          }\n\n          liActive = that.selectpicker.current.elements[liActiveIndex];\n          that.activeIndex = that.selectpicker.current.data[liActiveIndex].index;\n          that.focusItem(liActive);\n          that.selectpicker.view.currentActive = liActive;\n          if (updateScroll) that.$menuInner[0].scrollTop = offset;\n\n          if (that.options.liveSearch) {\n            that.$searchbox.trigger('focus');\n          } else {\n            $this.trigger('focus');\n          }\n        } else if (!$this.is('input') && !REGEXP_TAB_OR_ESCAPE.test(e.which) || e.which === keyCodes.SPACE && that.selectpicker.keydown.keyHistory) {\n          var searchMatch,\n              matches = [],\n              keyHistory;\n          e.preventDefault();\n          that.selectpicker.keydown.keyHistory += keyCodeMap[e.which];\n          if (that.selectpicker.keydown.resetKeyHistory.cancel) clearTimeout(that.selectpicker.keydown.resetKeyHistory.cancel);\n          that.selectpicker.keydown.resetKeyHistory.cancel = that.selectpicker.keydown.resetKeyHistory.start();\n          keyHistory = that.selectpicker.keydown.keyHistory; // if all letters are the same, set keyHistory to just the first character when searching\n\n          if (/^(.)\\1+$/.test(keyHistory)) {\n            keyHistory = keyHistory.charAt(0);\n          } // find matches\n\n\n          for (var i = 0; i < that.selectpicker.current.data.length; i++) {\n            var li = that.selectpicker.current.data[i],\n                hasMatch;\n            hasMatch = stringSearch(li, keyHistory, 'startsWith', true);\n\n            if (hasMatch && that.selectpicker.view.canHighlight[i]) {\n              matches.push(li.index);\n            }\n          }\n\n          if (matches.length) {\n            var matchIndex = 0;\n            $items.removeClass('active').find('a').removeClass('active'); // either only one key has been pressed or they are all the same key\n\n            if (keyHistory.length === 1) {\n              matchIndex = matches.indexOf(that.activeIndex);\n\n              if (matchIndex === -1 || matchIndex === matches.length - 1) {\n                matchIndex = 0;\n              } else {\n                matchIndex++;\n              }\n            }\n\n            searchMatch = matches[matchIndex];\n            activeLi = that.selectpicker.main.data[searchMatch];\n\n            if (scrollTop - activeLi.position > 0) {\n              offset = activeLi.position - activeLi.height;\n              updateScroll = true;\n            } else {\n              offset = activeLi.position - that.sizeInfo.menuInnerHeight; // if the option is already visible at the current scroll position, just keep it the same\n\n              updateScroll = activeLi.position > scrollTop + that.sizeInfo.menuInnerHeight;\n            }\n\n            liActive = that.selectpicker.main.elements[searchMatch];\n            that.activeIndex = matches[matchIndex];\n            that.focusItem(liActive);\n            if (liActive) liActive.firstChild.focus();\n            if (updateScroll) that.$menuInner[0].scrollTop = offset;\n            $this.trigger('focus');\n          }\n        } // Select focused option if \"Enter\", \"Spacebar\" or \"Tab\" (when selectOnTab is true) are pressed inside the menu.\n\n\n        if (isActive && (e.which === keyCodes.SPACE && !that.selectpicker.keydown.keyHistory || e.which === keyCodes.ENTER || e.which === keyCodes.TAB && that.options.selectOnTab)) {\n          if (e.which !== keyCodes.SPACE) e.preventDefault();\n\n          if (!that.options.liveSearch || e.which !== keyCodes.SPACE) {\n            that.$menuInner.find('.active a').trigger('click', true); // retain active class\n\n            $this.trigger('focus');\n\n            if (!that.options.liveSearch) {\n              // Prevent screen from scrolling if the user hits the spacebar\n              e.preventDefault(); // Fixes spacebar selection of dropdown items in FF & IE\n\n              $(document).data('spaceSelect', true);\n            }\n          }\n        }\n      },\n      mobile: function mobile() {\n        // ensure mobile is set to true if mobile function is called after init\n        this.options.mobile = true;\n        this.$element[0].classList.add('mobile-device');\n      },\n      refresh: function refresh() {\n        // update options if data attributes have been changed\n        var config = $.extend({}, this.options, this.$element.data());\n        this.options = config;\n        this.checkDisabled();\n        this.buildData();\n        this.setStyle();\n        this.render();\n        this.buildList();\n        this.setWidth();\n        this.setSize(true);\n        this.$element.trigger('refreshed' + EVENT_KEY);\n      },\n      hide: function hide() {\n        this.$newElement.hide();\n      },\n      show: function show() {\n        this.$newElement.show();\n      },\n      remove: function remove() {\n        this.$newElement.remove();\n        this.$element.remove();\n      },\n      destroy: function destroy() {\n        this.$newElement.before(this.$element).remove();\n\n        if (this.$bsContainer) {\n          this.$bsContainer.remove();\n        } else {\n          this.$menu.remove();\n        }\n\n        if (this.selectpicker.view.titleOption && this.selectpicker.view.titleOption.parentNode) {\n          this.selectpicker.view.titleOption.parentNode.removeChild(this.selectpicker.view.titleOption);\n        }\n\n        this.$element.off(EVENT_KEY).removeData('selectpicker').removeClass('bs-select-hidden selectpicker');\n        $(window).off(EVENT_KEY + '.' + this.selectId);\n      }\n    }; // SELECTPICKER PLUGIN DEFINITION\n    // ==============================\n\n    function Plugin(option) {\n      // get the args of the outer function..\n      var args = arguments; // The arguments of the function are explicitly re-defined from the argument list, because the shift causes them\n      // to get lost/corrupted in android 2.3 and IE9 #715 #775\n\n      var _option = option;\n      [].shift.apply(args); // if the version was not set successfully\n\n      if (!version.success) {\n        // try to retreive it again\n        try {\n          version.full = ($.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.');\n        } catch (err) {\n          // fall back to use BootstrapVersion if set\n          if (Selectpicker.BootstrapVersion) {\n            version.full = Selectpicker.BootstrapVersion.split(' ')[0].split('.');\n          } else {\n            version.full = [version.major, '0', '0'];\n            console.warn('There was an issue retrieving Bootstrap\\'s version. ' + 'Ensure Bootstrap is being loaded before bootstrap-select and there is no namespace collision. ' + 'If loading Bootstrap asynchronously, the version may need to be manually specified via $.fn.selectpicker.Constructor.BootstrapVersion.', err);\n          }\n        }\n\n        version.major = version.full[0];\n        version.success = true;\n      }\n\n      if (version.major === '4') {\n        // some defaults need to be changed if using Bootstrap 4\n        // check to see if they have already been manually changed before forcing them to update\n        var toUpdate = [];\n        if (Selectpicker.DEFAULTS.style === classNames.BUTTONCLASS) toUpdate.push({\n          name: 'style',\n          className: 'BUTTONCLASS'\n        });\n        if (Selectpicker.DEFAULTS.iconBase === classNames.ICONBASE) toUpdate.push({\n          name: 'iconBase',\n          className: 'ICONBASE'\n        });\n        if (Selectpicker.DEFAULTS.tickIcon === classNames.TICKICON) toUpdate.push({\n          name: 'tickIcon',\n          className: 'TICKICON'\n        });\n        classNames.DIVIDER = 'dropdown-divider';\n        classNames.SHOW = 'show';\n        classNames.BUTTONCLASS = 'btn-light';\n        classNames.POPOVERHEADER = 'popover-header';\n        classNames.ICONBASE = '';\n        classNames.TICKICON = 'bs-ok-default';\n\n        for (var i = 0; i < toUpdate.length; i++) {\n          var option = toUpdate[i];\n          Selectpicker.DEFAULTS[option.name] = classNames[option.className];\n        }\n      }\n\n      var value;\n      var chain = this.each(function () {\n        var $this = $(this);\n\n        if ($this.is('select')) {\n          var data = $this.data('selectpicker'),\n              options = _typeof(_option) == 'object' && _option;\n\n          if (!data) {\n            var dataAttributes = $this.data();\n\n            for (var dataAttr in dataAttributes) {\n              if (Object.prototype.hasOwnProperty.call(dataAttributes, dataAttr) && $.inArray(dataAttr, DISALLOWED_ATTRIBUTES) !== -1) {\n                delete dataAttributes[dataAttr];\n              }\n            }\n\n            var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, dataAttributes, options);\n            config.template = $.extend({}, Selectpicker.DEFAULTS.template, $.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}, dataAttributes.template, options.template);\n            $this.data('selectpicker', data = new Selectpicker(this, config));\n          } else if (options) {\n            for (var i in options) {\n              if (Object.prototype.hasOwnProperty.call(options, i)) {\n                data.options[i] = options[i];\n              }\n            }\n          }\n\n          if (typeof _option == 'string') {\n            if (data[_option] instanceof Function) {\n              value = data[_option].apply(data, args);\n            } else {\n              value = data.options[_option];\n            }\n          }\n        }\n      });\n\n      if (typeof value !== 'undefined') {\n        // noinspection JSUnusedAssignment\n        return value;\n      } else {\n        return chain;\n      }\n    }\n\n    var old = $.fn.selectpicker;\n    $.fn.selectpicker = Plugin;\n    $.fn.selectpicker.Constructor = Selectpicker; // SELECTPICKER NO CONFLICT\n    // ========================\n\n    $.fn.selectpicker.noConflict = function () {\n      $.fn.selectpicker = old;\n      return this;\n    }; // get Bootstrap's keydown event handler for either Bootstrap 4 or Bootstrap 3\n\n\n    function keydownHandler() {\n      if ($.fn.dropdown) {\n        // wait to define until function is called in case Bootstrap isn't loaded yet\n        var bootstrapKeydown = $.fn.dropdown.Constructor._dataApiKeydownHandler || $.fn.dropdown.Constructor.prototype.keydown;\n        return bootstrapKeydown.apply(this, arguments);\n      }\n    }\n\n    $(document).off('keydown.bs.dropdown.data-api').on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > [data-toggle=\"dropdown\"]', keydownHandler).on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > .dropdown-menu', keydownHandler).on('keydown' + EVENT_KEY, '.bootstrap-select [data-toggle=\"dropdown\"], .bootstrap-select [role=\"listbox\"], .bootstrap-select .bs-searchbox input', Selectpicker.prototype.keydown).on('focusin.modal', '.bootstrap-select [data-toggle=\"dropdown\"], .bootstrap-select [role=\"listbox\"], .bootstrap-select .bs-searchbox input', function (e) {\n      e.stopPropagation();\n    }); // SELECTPICKER DATA-API\n    // =====================\n\n    $(window).on('load' + EVENT_KEY + '.data-api', function () {\n      $('.selectpicker').each(function () {\n        var $selectpicker = $(this);\n        Plugin.call($selectpicker, $selectpicker.data());\n      });\n    });\n  })(jQuery);\n});","map":null,"metadata":{},"sourceType":"module"}